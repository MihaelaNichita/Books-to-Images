2. The simplest agents discussed in Chapter 2 were the reflex agents, which base their actions on a direct mapping from states to actions. Such agents cannot operate well in environments for which this mapping would be too large to store and would take too long to learn. Goal-based agents, on the other hand, can succeed by considering future actions and the desirability of their outcomes. This chapter describes one kind of goal-based agent called a problem-solving agent.
3.  PROBLEM-SOLVING AGENT Problem-solving agents think about the world using atomic representations, as described in Section 2.4.7—that is, states of the world are considered as wholes, with no internal structure visible to the problem-solving algorithms. Goal-based agents that use more advanced fac- tored or structured representations are usually called planning agents and are discussed in Chapter 7 and 11. .
4. We start our discussion of problem solving by defining precisely the elements that con- stitute a “problem” and its “solution,” and give several examples to illustrate these definitions. We then describe several general-purpose search algorithms that can be used to solve these problems. We will see several uninformed search algorithms—algorithms that are given no information about the problem other than its definition.
5.  Although some of these algorithms can solve any solvable problem, none of them can do so efficiently. Informed search al- gorithms, on the other hand, can often do quite well given some idea of where to look for solutions. .
6. In this chapter, we limit ourselves to the simplest kind of task environment, for which the solution to a problem is always a fixed sequence of actions. The more general case—where the agent’s future actions may vary depending on future percepts—is handled in Chapter 4. 
7. This chapter uses concepts from the analysis of algorithms. Readers unfamiliar with the concepts of asymptotic complexity (that is, O() notation) and NP-completeness should consult Appendix A. 65 3 SOLVING PROBLEMS BY SEARCHING Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
8. 66 Chapter 3. Solving Problems by Searching 3.1 PROBLEM-SOLVING AGENTS Intelligent agents are supposed to maximize their performance measure. As we mentioned in Chapter 2, achieving this is sometimes simplified if the agent can adopt a goal and aim at satisfying it. Let us first look at why and how an agent might do this. 
9. Imagine an agent in the city of Arad, Romania, enjoying a touring holiday. The agent’s performance measure contains many factors: it wants to improve its suntan, improve its Ro- manian, take in the sights, enjoy the nightlife (such as it is), avoid hangovers, and so on. The decision problem is a complex one involving many tradeoffs and careful reading of guide- books. Now, suppose the agent has a nonrefundable ticket to fly out of Bucharest the follow- ing day.
10.  In that case, it makes sense for the agent to adopt the goal of getting to Bucharest. Courses of action that don’t reach Bucharest on time can be rejected without further consid- eration and the agent’s decision problem is greatly simplified. Goals help organize behavior by limiting the objectives that the agent is trying to achieve and hence the actions it needs .
11. GOAL FORMULATION to consider. Goal formulation, based on the current situation and the agent’s performance measure, is the first step in problem solving. We will consider a goal to be a set of world states—exactly those states in which the goal is satisfied. The agent’s task is to find out how to act, now and in the future, so that it reaches a goal state.
12.  Before it can do this, it needs to decide (or we need to decide on its behalf) what sorts of actions and states it should consider. If it were to consider actions at the level of “move the left foot forward an inch” or “turn the steering wheel one degree left,” the agent would probably never find its way out of the parking lot, let alone to Bucharest, because at that level of detail there is too much uncertainty in the world and there would be PROBLEM FORMULATION too many steps in a solution.
13.  Problem formulation is the process of deciding what actions and states to consider, given a goal. We will discuss this process in more detail later. For now, let us assume that the agent will consider actions at the level of driving from one major town to another. Each state therefore corresponds to being in a particular town.
14. Our agent has now adopted the goal of driving to Bucharest, and is considering where to go from Arad. There are three roads out of Arad, one toward Sibiu, one to Timisoara, and one to Zerind. None of these achieves the goal, so unless the agent is very familiar with the geography of Romania, it will not know which road to follow.1 In other words, the agent will not know which of its possible actions is best, because it does not yet know enough about the state that results from taking each action.
15.  If the agent has no additional information—i.e., if the environment is unknown in the sense defined in Section 2.3—then it is has no choice but to try one of the actions at random. This sad situation is discussed in Chapter 4. .
16. But suppose the agent has a map of Romania. The point of a map is to provide the agent with information about the states it might get itself into, and the actions it can take. The agent can use this information to consider subsequent stages of a hypothetical journey via each of the three towns, trying to find a journey that eventually gets to Bucharest. Once it has 
17. DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 1 We are assuming that most readers are in the same position and can easily imagine themselves to be as clueless as our agent. We apologize to Romanian readers who are unable to take advantage of this pedagogical device. 
18. AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
19. Section 3.1. Problem-Solving Agents 67 found a path on the map from Arad to Bucharest, it can achieve its goal by carrying out the driving actions that correspond to the legs of the journey. In general, an agent with several immediate options of unknown value can decide what to do by first examining future actions that eventually lead to states of known value. 
20. To be more specific about what we mean by “examining future actions,” we have to be more specific about properties of the environment, as defined in Section 2.3. For now, we will assume that the environment is observable, so that the agent always knows the current state. For the agent driving in Romania, it’s reasonable to suppose that each city on the map has a sign indicating its presence to arriving drivers.
21.  We will also assume the environment is discrete, so that at any given state there are only finitely many actions to choose from. This is true for navigating in Romania because each city is connected to a small number of other cities. We will assume the environment is known, so that the agent knows which states are reached by each action.
22.  (Having an accurate map suffices to meet this condition for navigation problems.) Finally, we assume that the environment is deterministic, so that each action has exactly one outcome. Under ideal conditions, this is true for the agent in Romania—it means that if it chooses to drive from Arad to Sibiu, it does end up in Sibiu.
23.  Of course, conditions are not always ideal, as we will see in Chapter 4. .
24. Under these assumptions, the solution to any problem is a fixed sequence of actions. “Of course!” one might say, “What else could it be?” Well, in general it could be a branching strategy that recommends different actions in the future depending on what percepts arrive. For example, under less than ideal conditions, the agent might plan to drive from Arad to Sibiu and then to Rimnicu Vilcea, but may also need to have a contingency plan in case it arrives by accident in Zerind instead of Sibiu.
25.  Fortunately, if the agent knows the initial state and the environment is known and deterministic, it knows exactly where it will be after the first action and what it will perceive. Since there is only one possible percept after the first action, the solution can specify only one possible second action, and so on. The process of looking for a sequence of actions that reaches the goal is called search.
26.  SEARCH A search algorithm takes a problem as input and returns a solution in the form of an action SOLUTION sequence. Once a solution is found, the actions it recommends can be carried out. This is called the execution phase. Thus, we have a simple “formulate, search, execute” design EXECUTION for the agent, as shown in Figure 3.1. After formulating a goal and a problem to solve, the agent calls a search procedure to solve it.
27.  It then uses the solution to guide its actions, doing whatever the solution recommends as the next thing to do—typically, the first action of the sequence—and then removing that step from the sequence. Once the solution has been executed, the agent will formulate a new goal. .
28. Notice that while the agent is executing the solution sequence it ignores its percepts when choosing an action because it knows in advance what they will be. An agent that carries out its plans with its eyes closed, so to speak, must be quite certain of what is going on. Control theorists call this an open-loop system, because ignoring the percepts breaks the OPEN-LOOP 
29. loop between agent and environment. We first describe the process of problem formulation, and then devote the bulk of the chapter to various algorithms for the SEARCH function. We will not discuss the workings of the UPDATE-STATE and FORMULATE-GOAL functions further in this chapter. 
30. AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 68 Chapter 3. Solving Problems by Searching 3.1.1 Well-defined problems and solutions PROBLEM A problem can be defined formally by five components: INITIAL STATE 
31. • The initial state that the agent starts in. For example, the initial state for our agent in Romania might be described as In(Arad). ACTIONS • A description of the possible actions available to the agent. Given a particular state s, ACTIONS(s) returns the set of actions that can be executed in s. For example, from the state In(Arad), the possible actions are {Go(Sibiu),Go(Timisoara),Go(Zerind)}. 
32. • A description of what each action does; the formal name for this is the transition TRANSITION MODEL model, specified by a function RESULT(s,a) that returns the state that results from SUCCESSOR doing action a in state s. We will also use the term successor to refer to any state reachable from a given state by a single action.2 For example, we have 
33. RESULT(In(Arad),Go(Zerind)) = In(Zerind) . STATE SPACE Together, the initial state, actions, and transition model implicitly define the state space of the problem—the set of all states reachable from the initial state by any sequence GRAPH of actions. The state space forms a directed network or graph in which the nodes are states and the links between nodes are actions.
34.  (The map of Romania shown in Figure 3.2 can be interpreted as a state-space graph if we view each road as standing .
35. PATH for two driving actions, one in each direction.) A path in the state space is a sequence of states connected by a sequence of actions. DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
36. 2 Many treatments of problem solving, including previous editions of this book, talk about the successor func- tion, which returns the set of all successors, instead of actions and results. Although convenient in some ways, this formulation makes it difficult to describe an agent that knows what actions it can try but not what they achieve. 
39. Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. Section 3.1. Problem-Solving Agents 69 
40. • The goal test, which determines whether a given state is a goal state. Sometimes there GOAL TEST is an explicit set of possible goal states, and the test simply checks whether the given state is one of them. The agent’s goal in Romania is the singleton set {In(Bucharest)}.
41.  Sometimes the goal is specified by an abstract property rather than an explicitly enumer- ated set of states. For example, in chess, the goal is to reach a state called “checkmate,” where the opponent’s king is under attack and can’t escape. .
42. • A path cost function that assigns a numeric cost to each path. The problem-solving PATH COST agent chooses a cost function that reflects its own performance measure. For the agent trying to get to Bucharest, time is of the essence, so the cost of a path might be its length in kilometers. In this chapter, we assume that the cost of a path can be described as the sum of the costs of the individual actions along the path.
44. The preceding elements define a problem and can be gathered together into a single data structure that is given as input to a problem-solving algorithm. A solution to a problem is an action sequence that leads from the initial state to a goal state. Solution quality is measured by the path cost function, and an optimal solution has the lowest path cost among all solutions. OPTIMAL SOLUTION 
45. 3 This assumption is algorithmically convenient, but also has a more fundamental justification—see page 629 in Chapter 17. 4 The implications of negative costs are explored in Exercise 3.29. AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE Oradea 71 
46. 75 Zerind 151 Arad 140 Sibiu 99 Fagaras 118 80 Timisoara 111 Lugoj 97 Pitesti 70Mehadia 101 75 Drobeta 120 Craiova Figure 3.2 A simplified road map of part of Romania. Iasi Rimnicu Vilcea 211 146 85 138 Bucharest 90 
47. Giurgiu Neamt 87 92 Vaslui 14298 Hirsova Urziceni 86 Eforie Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 70 Chapter 3. Solving Problems by Searching 3.1.2 Formulating problems In the preceding section we proposed a formulation of the problem of getting to Bucharest in terms of the initial state, actions, transition model, goal test, and path cost.
48.  This formulation seems reasonable, but it is still a model—an abstract mathematical description—and not the real thing. Compare the simple state description we have chosen, In(Arad), to an actual cross- country trip, where the state of the world includes so many things: the traveling companions, what is on the radio, the scenery out of the window, whether there are any law enforcement officers nearby, how far it is to the next rest stop, the condition of the road, the weather, and so on.
49.  All these considerations are left out of our state descriptions because they are irrelevant to the problem of finding a route to Bucharest. The process of removing detail .
50. ABSTRACTION from a representation is called abstraction. In addition to abstracting the state description, we must abstract the actions themselves. A driving action has many effects. Besides changing the location of the vehicle and its oc- cupants, it takes up time, consumes fuel, generates pollution, and changes the agent (as they say, travel is broadening). Our formulation takes into account only the change in location.
51.  Also, there are many actions that we will omit altogether: turning on the radio, looking out of the window, slowing down for law enforcement officers, and so on. And of course, we don’t specify actions at the level of “turn steering wheel to the left by three degrees.” .
52. Can we be more precise about defining the appropriate level of abstraction? Think of the abstract states and actions we have chosen as corresponding to large sets of detailed world states and detailed action sequences. Now consider a solution to the abstract problem: for example, the path from Arad to Sibiu to Rimnicu Vilcea to Pitesti to Bucharest. This abstract solution corresponds to a large number of more detailed paths.
53.  For example, we could drive with the radio on between Sibiu and Rimnicu Vilcea, and then switch it off for the rest of the trip. The abstraction is valid if we can expand any abstract solution into a solution in the more detailed world; a sufficient condition is that for every detailed state that is “in Arad,” there is a detailed path to some state that is “in Sibiu,” and so on.
54. 5 The abstraction is useful if carrying out each of the actions in the solution is easier than the original problem; in this case they are easy enough that they can be carried out without further search or planning by an average driving agent. The choice of a good abstraction thus involves removing as much detail as possible while retaining validity and ensuring that the abstract actions are easy to carry out.
55.  Were it not for the ability to construct useful abstractions, intelligent agents would be completely swamped by the real world. .
56. 3.2 EXAMPLE PROBLEMS The problem-solving approach has been applied to a vast array of task environments. We list some of the best known here, distinguishing between toy and real-world problems. A TOY PROBLEM toy problem is intended to illustrate or exercise various problem-solving methods. It can be DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
57. 5 See Section 12.2 for a more complete set of definitions and algorithms. AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
58. Section 3.2. Example Problems 71 given a concise, exact description and hence is usable by different researchers to compare the performance of algorithms. A real-world problem is one whose solutions people actually REAL-WORLD PROBLEM care about. They tend not to have a single agreed-upon description, but we will attempt to 
59. give the general flavor of their formulations. 3.2.1 Toy problems The first example we will examine is the vacuum world first introduced in Chapter 2. (See Figure 2.2.) This can be formulated as a problem as follows: • States: The state is determined by both the agent location and the dirt locations.
60.  The agent is in one of two locations, each of which might or might not contain dirt. Thus there are 2 × 22 = 8 possible world states. A larger environment with n locations has n · 2n states. .
61. • Initial state: Any state can be designated as the initial state. • Actions: In this simple environment, each state has just three actions: Left, Right, and Suck. Larger environments might also include Up and Down. • Transition model: The actions have their expected effects, except that moving Left in the leftmost square, moving Right in the rightmost square, and Sucking in a clean square have no effect. The complete state space is shown in Figure 3.3. 
62. • Goal test: This checks whether all the squares are clean. • Path cost: Each step costs 1, so the path cost is the number of steps in the path. Compared with the real world, this toy problem has discrete locations, discrete dirt, reliable cleaning, and it never gets messed up once cleaned. In Chapter 4, we will relax some of these assumptions. The 8-puzzle, an instance of which is shown in Figure 3.
63. 4, consists of a 3×3 board with 8-PUZZLE eight numbered tiles and a blank space. A tile adjacent to the blank space can slide into the space. The object is to reach a specified goal state, such as the one shown on the right of the figure. The standard formulation is as follows: .
64. • States: A state description specifies the location of each of the eight tiles and the blank in one of the nine squares. • Initial state: Any state can be designated as the initial state. Note that any given goal can be reached from exactly half of the possible initial states (Exercise 3.17). 
65. • Actions: The simplest formulation defines the actions as movements of the blank space Left, Right, Up, or Down. Different subsets of these are possible depending on where the blank is. • Transition model: Given a state and action, this returns the resulting state; for example, if we apply Left to the start state in Figure 3.4, the resulting state has the 5 and the blank switched. 
66. • Goal test: This checks whether the state matches the goal configuration shown in Fig- ure 3.4. (Other goal configurations are possible.) • Path cost: Each step costs 1, so the path cost is the number of steps in the path. 
67. AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 72 Chapter 3. Solving Problems by Searching What abstractions have we included here? The actions are abstracted to their beginning and final states, ignoring the intermediate locations where the block is sliding.
68.  We have abstracted away actions such as shaking the board when pieces get stuck, or extracting the pieces with a knife and putting them back again. We are left with a description of the rules of the puzzle, avoiding all the details of physical manipulations. SLIDING-BLOCK PUZZLES The 8-puzzle belongs to the family of sliding-block puzzles, which are often used as test problems for new search algorithms in AI.
69.  This family is known to be NP-complete, so one does not expect to find methods significantly better in the worst case than the search algorithms described in this chapter and the next. The 8-puzzle has 9!/2 = 181,440 reachable states and is easily solved. The 15-puzzle (on a 4×4 board) has around 1.
70. 3 trillion states, and random instances can be solved optimally in a few milliseconds by the best search algorithms. .
71. DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE L L R RR R 
72. Figure 3.3 The state space for the vacuum world. Links denote actions: L = Left,R= Right,S= Suck. Figure 3.4 A typical instance of the 8-puzzle. S S S RL 785 8 LL 23 46 1 2 3 4 6 7 
73. Start State Goal State 5 1 RL S S S S RL RL S Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
74. Section 3.2. Example Problems 73 The 24-puzzle (on a 5 × 5 board) has around 1025 states, and random instances take several hours to solve optimally. The goal of the 8-queens problem is to place eight queens on a chessboard such that 8-QUEENS PROBLEM no queen attacks any other.
75.  (A queen attacks any piece in the same row, column or diago- nal.) Figure 3.5 shows an attempted solution that fails: the queen in the rightmost column is attacked by the queen at the top left. .
76. Although efficient special-purpose algorithms exist for this problem and for the whole n-queens family, it remains a useful test problem for search algorithms. There are two main kinds of formulation. An incremental formulation involves operators that augment the state INCREMENTAL FORMULATION description, starting with an empty state; for the 8-queens problem, this means that each action adds a queen to the state.
77.  A complete-state formulation starts with all 8 queens on COMPLETE-STATE FORMULATION the board and moves them around. In either case, the path cost is of no interest because only .
78. the final state counts. The first incremental formulation one might try is the following: • States: Any arrangement of 0 to 8 queens on the board is a state. • Initial state: No queens on the board. • Actions: Add a queen to any empty square. 
81. Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 74 Chapter 3. Solving Problems by Searching • Actions: Add a queen to any square in the leftmost empty column such that it is not attacked by any other queen. This formulation reduces the 8-queens state space from 1.8×1014 to just 2,057, and solutions are easy to find.
82.  On the other hand, for 100 queens the reduction is from roughly 10400 states to about 1052 states (Exercise 3.18)—a big improvement, but not enough to make the problem tractable. Section 4.1 describes the complete-state formulation and Chapter 6 gives a simple algorithm that solves even the million-queens problem with ease. .
85. • Goal test: State is the desired positive integer. To our knowledge there is no bound on how large a number might be constructed in the pro- cess of reaching a given target—for example, the number 620,448,401,733,239,439,360,000 is generated in the expression for 5—so the state space for this problem is infinite. Such state spaces arise very frequently in tasks involving the generation of mathematical expressions, circuits, proofs, programs, and other recursively defined objects. 
86. 3.2.2 Real-world problems ROUTE-FINDING PROBLEM We have already seen how the route-finding problem is defined in terms of specified loca- tions and transitions along links between them. Route-finding algorithms are used in a variety of applications. Some, such as Web sites and in-car systems that provide driving directions, are relatively straightforward extensions of the Romania example.
87.  Others, such as routing video streams in computer networks, military operations planning, and airline travel planning systems, involve much more complex specifications. Consider the airline travel problems that must be solved by a travel planning Web site: .
88. • States: Each state obviously includes a location (e.g., an airport) and the current time. Furthermore, because the cost of an action (a flight segment) may depend on previous segments, their fare bases, and whether they were domestic or international, the state must record extra information about these “historical” aspects. 
89. • Initial state: This is specified by the user’s query. AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
91. Section 3.2. Example Problems 75 • Actions: Take any flight from the current location, in any seat class, leaving after the current time, leaving enough time for within-airport transfer if there is a preceding flight segment. • Transition model: The state resulting from taking a flight will have the flight’s desti- nation as the current location and the flight’s arrival time as the current time. 
92. • Goal test: Are we at the final destination specified by the user? • Path cost: This depends on monetary cost, waiting time, flight time, customs and im- migration procedures, seat quality, time of day, type of airplane, frequent-flyer mileage awards, and so on. 
93. Commercial travel advice systems use a problem formulation of this kind, with many addi- tional complications to handle the byzantine fare structures that airlines impose. Any sea- soned traveler knows, however, that not all air travel goes according to plan. A really good system should include contingency plans—such as backup reservations on alternate flights— to the extent that these are justified by the cost and likelihood of failure of the original plan.
94.  Touring problems are closely related to route-finding problems, but with an impor- TOURING PROBLEMS tant difference. Consider, for example, the problem “Visit every city in Figure 3.2 at least once, starting and ending in Bucharest.” As with route finding, the actions correspond to trips between adjacent cities. The state space, however, is quite different. Each state must include not just the current location but also the set of cities the agent has visited.
95.  So the initial state would be In(Bucharest),Visited({Bucharest}), a typical intermedi- ate state would be In(Vaslui),Visited({Bucharest,Urziceni,Vaslui}), and the goal test would check whether the agent is in Bucharest and all 20 cities have been visited. The traveling salesperson problem (TSP) is a touring problem in which each city TRAVELING SALESPERSON PROBLEM must be visited exactly once. The aim is to find the shortest tour.
96.  The problem is known to be NP-hard, but an enormous amount of effort has been expended to improve the capabilities of TSP algorithms. In addition to planning trips for traveling salespersons, these algorithms have been used for tasks such as planning movements of automatic circuit-board drills and of stocking machines on shop floors. A VLSI layout problem requires positioning millions of components and connections VLSI LAYOUT on a chip to minimize area, minimize circuit delays, minimize stray capacitances, and max- imize manufacturing yield.
97.  The layout problem comes after the logical design phase, and is usually split into two parts: cell layout and channel routing. In cell layout, the primitive components of the circuit are grouped into cells, each of which performs some recognized function. Each cell has a fixed footprint (size and shape) and requires a certain number of connections to each of the other cells.
98.  The aim is to place the cells on the chip so that they do not overlap and so that there is room for the connecting wires to be placed between the cells. Channel routing finds a specific route for each wire through the gaps between the cells. These search problems are extremely complex, but definitely worth solving. Later in this chapter, we will see some algorithms capable of solving them.
99.  Robot navigation is a generalization of the route-finding problem described earlier. ROBOT NAVIGATION Rather than a discrete set of routes, a robot can move in a continuous space with (in principle) an infinite set of possible actions and states. For a circular robot moving on a flat surface, .
100. AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 76 Chapter 3. Solving Problems by Searching the space is essentially two-dimensional. When the robot has arms and legs or wheels that must also be controlled, the search space becomes many-dimensional. Advanced techniques are required just to make the search space finite.
101.  We examine some of these methods in Chapter 25. In addition to the complexity of the problem, real robots must also deal with errors in their sensor readings and motor controls. AUTOMATIC ASSEMBLY SEQUENCING Automatic assembly sequencing of complex objects by a robot was first demonstrated by FREDDY (Michie, 1972). Progress since then has been slow but sure, to the point where the assembly of intricate objects such as electric motors is economically feasible.
102.  In assembly problems, the aim is to find an order in which to assemble the parts of some object. If the wrong order is chosen, there will be no way to add some part later in the sequence without undoing some of the work already done. Checking a step in the sequence for feasibility is a difficult geometrical search problem closely related to robot navigation.
103.  Thus, the generation of legal actions is the expensive part of assembly sequencing. Any practical algorithm must avoid exploring all but a tiny fraction of the state space. Another important assembly problem .
104. PROTEIN DESIGN is protein design, in which the goal is to find a sequence of amino acids that will fold into a three-dimensional protein with the right properties to cure some disease. 3.3 SEARCHING FOR SOLUTIONS Having formulated some problems, we now need to solve them. A solution is an action sequence, so search algorithms work by considering various possible action sequences. The 
105. SEARCH TREE possible action sequences starting at the initial state form a search tree with the initial state NODE at the root; the branches are actions and the nodes correspond to states in the state space of the problem. Figure 3.6 shows the first few steps in growing the search tree for finding a route from Arad to Bucharest.
106.  The root node of the tree corresponds to the initial state, In(Arad). The first step is to test whether this is a goal state. (Clearly it is not, but it is important to check so that we can solve trick problems like “starting in Arad, get to Arad.”) Then we .
107. EXPANDING need to consider taking various actions. This is done by expanding the current state; that GENERATING is, applying each legal action to the current state, thereby generating a new set of states. In PARENT NODE this case, we add three branches from the parent node In(Arad) leading to three new child CHILD NODE nodes: In(Sibiu), In(Timisoara), and In(Zerind). Now we must choose which of these three possibilities to consider further.
108.  This is the essence of search—following up one option now and putting the others aside for later, in case the first choice does not lead to a solution. Suppose we choose Sibiu first. We check to see whether it is a goal state (it is not) and then expand it to get In(Arad), In(Fagaras), In(Oradea), and In(RimnicuVilcea). We can then choose any of these four, or go .
109. LEAF NODE back and choose Timisoara or Zerind. Each of these six nodes is a leaf node, that is, a node with no children in the tree. The set of all leaf nodes available for expansion at any given FRONTIER point is called the frontier. (Many authors call it the open list, which is both geographically OPEN LIST less evocative and inaccurate, as it need not be stored as a list at all.) In Figure 3.6, the frontier 
110. of each tree consists of those nodes with bold outlines. AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
111. Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. Section 3.3. Searching for Solutions 77 
112. The process of choosing and expanding nodes in the frontier continues until either a solution is found or there are no more states to be expanded. The general TREE-SEARCH algorithm is shown informally in Figure 3.7. Search algorithms all share this basic structure; they vary primarily according to how they choose which state to expand next—the so-called search strategy. SEARCH STRATEGY 
113. The eagle-eyed reader will notice one peculiar thing about the search tree shown in Fig- ure 3.6: it includes the path from Arad to Sibiu and back to Arad again! We say that In(Arad) is a repeated state in the search tree, generated in this case by a loopy path.
114.  Considering REPEATED STATE LOOPY PATH such loopy paths means that the complete search tree for Romania is infinite, because there is no limit to how often one can traverse a loop. On the other hand, the state space—the map shown in Figure 3.2—has only 20 states.
115.  As we will see in Section 3.4, loops can cause certain algorithms to fail, making otherwise solvable problems unsolvable. Fortunately, there is no need to consider loopy paths. We can rely on more than intuition for this: because path costs are additive and step costs are nonnegative, a loopy path to any given state is never better than the same path with the loop removed.
116.  Loopy paths are a special case of the more general concept of redundant paths, which REDUNDANT PATH .
117. Figure 3.6 Partial search trees for finding a route from Arad to Bucharest. Nodes that have been expanded are shaded; nodes that have been generated but not yet expanded are outlined in bold; nodes that have not yet been generated are shown in faint dashed lines. 
118. (a) The initial state (b) After expanding Arad (c) After expanding Sibiu AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE Arad Sibiu Zerind Arad Fagaras Oradea Rimnicu Vilcea Timisoara Rimnicu Vilcea Arad Lugoj Arad Oradea Arad Sibiu Timisoara 
119. Zerind Arad Fagaras Oradea Rimnicu Vilcea Arad Lugoj Arad Oradea Arad Sibiu Timisoara Zerind Arad Fagaras Oradea Arad Lugoj Arad Oradea Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 78 Chapter 3. Solving Problems by Searching 
120. exist whenever there is more than one way to get from one state to another. Consider the paths Arad–Sibiu (140km long) and Arad–Zerind–Oradea–Sibiu (297km long). Obviously, the second path is redundant—it’s just a worse way to get to the same state. If you are concerned about reaching the goal, there’s never any reason to keep around more than one path to any given state, because any goal state that is reachable by extending one path is also reachable by extending the other.
121. In some cases, it is possible to define the problem itself so as to eliminate redundant paths. For example, if we formulate the 8-queens problem (page 73) so that a queen can be placed in any column, then each state with n queens can be reached by n! different paths; but if we reformulate the problem so that each new queen is placed in the leftmost empty column, then each state can be reached only through one path. 
122. In other cases, redundant paths are unavoidable. This includes all problems where the actions are reversible, such as route-finding problems and sliding-block puzzles. Route- RECTANGULAR GRID finding on a rectangular grid, as illustrated in Figure 3.9, is a particularly important example in computer games. In such a grid, each state has four successors, so a search tree of depth d that includes repeated states has 4d leaves; but there are only about 2d2 distinct states within d steps of any given state.
123.  For d = 20, this means about a trillion nodes but only about 800 distinct states. Thus, following redundant paths can cause a tractable problem to become intractable. This is true even for algorithms that know how to avoid infinite loops. .
124. As the saying goes, algorithms that forget their history are doomed to repeat it. The AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
125. function TREE-SEARCH(problem) returns a solution, or failure initialize the frontier using the initial state of problem loop do if the frontier is empty then return failure choose a leaf node and remove it from the frontier if the node contains a goal state then return the corresponding solution expand the chosen node, adding the resulting nodes to the frontier 
126. function GRAPH-SEARCH(problem) returns a solution, or failure initialize the frontier using the initial state of problem initialize the explored set to be empty loop do if the frontier is empty then return failure choose a leaf node and remove it from the frontier if the node contains a goal state then return the corresponding solution add the node to the explored set expand the chosen node, adding the resulting nodes to the frontier 
127. only if not in the frontier or explored set Figure 3.7 An informal description of the general tree-search and graph-search algo- rithms. The parts of GRAPH-SEARCH marked in bold italic are the additions needed to handle repeated states. Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
128. DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. Section 3.3. Searching for Solutions 79 way to avoid exploring redundant paths is to remember where one has been. To do this, we augment the TREE-SEARCH algorithm with a data structure called the explored set, which EXPLORED SET remembers every expanded node. (Many authors call this the closed list—see earlier com- CLOSED LIST ment on open lists.
129. ) Newly generated nodes that match previously generated nodes—ones in the explored set or the frontier—can be discarded instead of being added to the frontier. The new algorithm, called GRAPH-SEARCH, is shown informally in Figure 3.7. The spe- cific algorithms in this chapter are, for the most part, special cases or variants of this general design.Clearly, the search tree constructed by the GRAPH-SEARCH algorithm contains at most one copy of any given state, so we can think of it as growing a tree directly on the state- space graph itself, as shown in Figure 3.
130. 8. The algorithm has another nice property: the frontier separates the state-space graph into the explored region and the unexplored region, SEPARATOR so that every path from the initial state to an unexplored state has to pass through a state in the frontier. (If this seems completely obvious, try Exercise 3.20 now.) This property is illustrated in Figure 3.9. As every step moves a state from the frontier into the explored region, while moving some states from the unexplored region into the frontier, we see that the algorithm is systematically examining the states in the state space, one by one, until it finds a solution.
131. 3.3.1 Infrastructure for search algorithms Search algorithms require a data structure to keep track of the search tree that is being con- structed. For each node n of the tree, we will have a structure that contains the following four components: 
132. • n.STATE: the state in the state space to which the node corresponds; • n.PARENT: the node in the search tree that generated this node; • n.ACTION: the action that was applied to the parent to generate the node; • n.PATH-COST: the cost, traditionally denoted by g(n), of the path from the initial state to the node, as indicated by the parent pointers.
133.  Given the components for a parent node, it is easy to see how to compute the necessary components for a child node. The function CHILD-NODE takes a parent node and an action and returns the resulting child node: .
134. AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE Figure 3.8 A sequence of search trees generated by a graph search on the Romania prob- lem of Figure 3.2. At each stage, we have extended each path by one step. Notice that at the third stage, the northernmost city (Oradea) has become a dead end: both of its successors are already explored via other paths. 
135. Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 80 Chapter 3. Solving Problems by Searching The node data structure is depicted in Figure 3.10. Notice how the PARENT pointers string the nodes together into a tree structure. These pointers also allow the solution path to be extracted when a goal node is found; we’ll use the SOLUTION function to return the sequence of actions obtained by following parent pointers back to the root. 
136. Up to now, we have not been very careful to distinguish between nodes and states, but in writing detailed algorithms it’s important to do so. A node is a bookkeeping data structure used to represent the search tree. A state corresponds to a configuration of the world.
137.  Thus, nodes are on particular paths, as defined by PARENT pointers, whereas states are not. Furthermore, two different nodes can contain the same world state, if that state is generated via two different search paths. .
138. Now that we have nodes, we need somewhere to put them. The frontier needs to be stored in such a way that the search algorithm can easily choose the next node to expand QUEUE according to its preferred strategy. The appropriate data structure for this is a queue. The operations on a queue are as follows: 
139. • EMPTY?(queue) returns true only if there are no more elements in the queue. • POP(queue) removes the first element of the queue and returns it. • INSERT(element, queue) inserts an element and returns the resulting queue. AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE 
140. DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. function CHILD-NODE(problem,parent,action) returns a node return a node with STATE = problem.RESULT(parent.STATE,action), PARENT = parent, ACTION = action, PATH-COST = parent.PATH-COST + problem.STEP-COST(parent.STATE,action) 
141. Figure 3.9 The separation property of GRAPH-SEARCH, illustrated on a rectangular-grid problem. The frontier (white nodes) always separates the explored region of the state space (black nodes) from the unexplored region (gray nodes). In (a), just the root has been ex- panded. In (b), one leaf node has been expanded. In (c), the remaining successors of the root have been expanded in clockwise order. 
142. (c) (b) (a) Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
143. Section 3.3. Searching for Solutions 81 Queues are characterized by the order in which they store the inserted nodes. Three common variants are the first-in, first-out or FIFO queue, which pops the oldest element of the queue; FIFO QUEUE the last-in, first-out or LIFO queue (also known as a stack), which pops the newest element LIFO QUEUE of the queue; and the priority queue, which pops the element of the queue with the highest PRIORITY QUEUE 
144. priority according to some ordering function. The explored set can be implemented with a hash table to allow efficient checking for repeated states. With a good implementation, insertion and lookup can be done in roughly constant time, independent of the number of states stored. One must take care to implement the hash table with the right notion of equality between states. For example, in the traveling salesperson problem (page 75), the hash table needs to know that the set of visited cities {Bucharest,Urziceni,Vaslui} is the same as {Urziceni,Vaslui,Bucharest}.
145.  Sometimes this can be achieved most easily by insisting that the data structures for states be in some canonical form; that is, logically equivalent states should map to the same data structure. In the case CANONICAL FORM of states described by sets, for example, a bit-vector representation or a sorted list without repetition would be canonical, whereas an unsorted list would not. .
146. 3.3.2 Measuring problem-solving performance Before we get into the design of specific search algorithms, we need to consider the criteria that might be used to choose among them. We will evaluate an algorithm’s performance in four ways: • Completeness: Is the algorithm guaranteed to find a solution when there is one? COMPLETENESS 
147. • Optimality: Does the strategy find the optimal solution, as defined on page 69? OPTIMALITY • Time complexity: How long does it take to find a solution? TIME COMPLEXITY • Space complexity: How much memory is needed to perform the search? SPACE COMPLEXITY 
148. Time and space complexity are always considered with respect to some measure of the prob- lem difficulty. In theoretical computer science, the typical measure is the size of the state space graph, |V | + |E|. where V is the set of vertices (nodes) of the graph and E is the set 
149. AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE Figure 3.10 Nodes are the data structures from which the search tree is constructed. Each has a parent, a state, and various bookkeeping fields. Arrows point from child to parent. 
150. 8 4561 7 234561 8 7 23Node STATE PARENT ACTION = Right PATH-COST = 6 Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 82 Chapter 3. Solving Problems by Searching of edges (links). This is appropriate when the graph is an explicit data structure that is input to the search program.
151.  (The map of Romania is an example of this.) In AI, the graph is often represented implicitly by the initial state, actions, and transition model and is frequently infi- nite. For these reasons, complexity is expressed in terms of three quantities: b, the branching .
152. BRANCHING FACTOR factor or maximum number of successors of any node; d, the depth of the shallowest goal DEPTH node (i.e., the number of steps along the path from the root); and m, the maximum length of any path in the state space. Time is often measured in terms of the number of nodes generated during the search, and space in terms of the maximum number of nodes stored in memory.
153.  For the most part, we will describe time and space complexity for search on a tree; for a graph, the answer will depend on how “redundant” the paths in the state space are. .
154. SEARCH COST To assess the effectiveness of a search algorithm, we can consider just the search cost— which typically depends on the time complexity but can also include a term for memory TOTAL COST usage—or we can use the total cost, which combines the search cost and the path cost of the solution found.
155.  For the problem of finding a route from Arad to Bucharest, the search cost is the amount of time taken by the search and the solution cost is the total length of the path in kilometers. Thus, to compute the total cost, we have to add milliseconds and kilometers.
156.  There is no “official exchange rate” between the two, but it might be reasonable in this case to convert kilometers into milliseconds by using an estimate of the car’s average speed (because time is what the agent cares about). This enables the agent to find an optimal tradeoff point at which further computation to find a shorter path becomes counterproductive.
157.  The more general problem of tradeoffs between different goods will be taken up in Chapter 16. .
158. 3.4 UNINFORMED SEARCH STRATEGIES This section covers several search strategies that come under the heading of uninformed UNINFORMED SEARCH search (also called blind search). The term means that they have no additional informa- BLIND SEARCH tion about states beyond that provided in the problem definition. All they can do is generate successors and distinguish a goal state from a nongoal state. All search strategies are dis- tinguished by the order in which nodes are expanded. Strategies that know whether one 
159. INFORMED SEARCH non-goal state is “more promising” than another are called informed search or heuristic HEURISTIC SEARCH search strategies; they will be covered in Section 3.5. 3.4.1 Breadth-first search BREADTH-FIRST SEARCH Breadth-first search is a simple strategy in which the root node is expanded first, then all the successors of the root node are expanded next, then their successors, and so on.
160.  In general, all the nodes are expanded at a given depth in the search tree before any nodes at the next level are expanded. .
161. Breadth-first search is an instance of the general graph search algorithm (Figure 3.7) in which the shallowest unexpanded node is chosen for expansion. This is achieved very simply by using a FIFO queue for the frontier. Thus, new nodes (which are always deeper than their parents) go to the back of the queue and old nodes, which are shallower than the new nodes, 
162. AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
163. DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. Section 3.4. Uninformed Search Strategies 83 get expanded first. There is one slight tweak on the general graph search algorithm, which is that the goal test is applied to each node when it is generated, rather than when it is selected for expansion. This decision is explained below, where we discuss time complexity.
164.  Note also that the algorithm, following the general template for graph search, discards any new path to a state already in the frontier or explored set; it is easy to see that any such path must be at least as deep as the one already found. Thus, breadth-first search always has the shallowest path to every node on the frontier. .
165. Pseudocode is given in Figure 3.11. Figure 3.12 shows the progress of the search on a simple binary tree. How does breadth-first search rate according to the four criteria from the previous sec- tion? We can easily see that it is complete—if the shallowest goal node is at some finite depth d, breadth-first search will eventually find it after generating all shallower nodes (provided the branching factor b is finite). Note that as soon as a goal node is generated, we know it is the shallowest goal node because all shallower nodes must have been generated already and failed the goal test.
166.  Now, the shallowest goal node is not necessarily the optimal one; technically, breadth-first search is optimal if the path cost is a nondecreasing function of the depth of the node. The most common such scenario is when all actions have the same cost. .
167. A A A A A B C B C D E F G D E F G B B C C C D E F G D E F G B C B C B C B C E F G D 
170. Figure 3.11 Breadth-first search on a graph. Figure 3.12 Breadth-first search on a simple binary tree. At each stage, the node to be expanded next is indicated by a marker. AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE 
171. Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 84 Chapter 3. Solving Problems by Searching DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
172. So far, the news about breadth-first search has been good. The news about time and space is not so good. Imagine searching a uniform tree where every state has b successors. The root of the search tree generates b nodes at the first level, each of which generates b more nodes, for a total of b2 at the second level.
173.  Each of these generates b more nodes, yielding b3 nodes at the third level, and so on. Now suppose that the solution is at depth d. In the worst case, it is the last node generated at that level. Then the total number of nodes generated is .
174. b + b2 + b3 + ··· + bd = O(bd) . (If the algorithm were to apply the goal test to nodes when selected for expansion, rather than when generated, the whole layer of nodes at depth d would be expanded before detecting the goal, and the time complexity would be O(bd+1).) 
176. e., it is dominated by the size of the frontier. Switching to a tree search would not save much space, and in a state space with many redundant paths it could cost a great deal of time. .
177. An exponential complexity bound such as O(bd) is scary. Figure 3.13 shows why. It lists the time and memory required for a breadth-first search with branching factor b = 10, for various values of the solution depth d. The table assumes that 100,000 nodes can be generated per second and that a node requires 1000 bytes of storage. Many search problems fit roughly within these assumptions (give or take a factor of 100) when run on a modern personal computer. 
178. There are two lessons to be learned from Figure 3.13. First, the memory requirements are a bigger problem for breadth-first search than is the execution time. 31 hours would not be too long to wait for the solution to an important problem of depth 10, but few computers have the 10 terabytes of main memory it would take. Fortunately, there are other search strategies that require less memory. 
179. AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE Depth Nodes Time Memory Figure 3.13 Time and memory requirements for breadth-first search. The numbers shown assume branching factor b = 10; 100,000 nodes/second; 1000 bytes/node. 10 1010 31 hours 10 terabytes 
180. 12 1012 129 days 1 petabytes 14 1014 35 years 99 petabytes 16 1016 3,500 years 10 exabytes 2 110 1.1 milliseconds 107 kilobytes 4 11,110 111 milliseconds 10.6 megabytes 6 106 11 seconds 1 gigabytes 8 108 19 minutes 103 gigabytes 
181. Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. Section 3.4. Uninformed Search Strategies 85 
182. The second lesson is that the time requirements are still a major factor. If your problem has a solution at depth 16, then (given our assumptions) it will take about 3,500 years for breadth-first search (or indeed any uninformed search) to find it. In general, exponential- complexity search problems cannot be solved by uninformed methods for any but the smallest instances. 
183. 3.4.2 Uniform-cost search Breadth-first search is optimal when all step costs are equal, because it always expands the shallowest unexpanded node. By a simple extension, we can find an algorithm that is optimal with any step cost function. Instead of expanding the shallowest node, uniform-cost search UNIFORM-COST SEARCH expands the node n with the lowest path cost g(n). This is done by storing the frontier as a 
184. priority queue ordered by g. The algorithm is shown in Figure 3.14. In addition to the ordering of the queue by path cost, there are two other significant differences from breadth-first search. The first is that the goal test is applied to a node when it is selected for expansion (as in the generic graph search algorithm shown in Figure 3.
185. 7) rather than when it is first generated. The reason is that the first goal node that is generated may be on a suboptimal path. The second difference is that a test is added in case a better path is found to a node currently on the frontier. .
186. Both of these modifications come into play in the example shown in Figure 3.15, where the problem is to get from Sibiu to Bucharest. The successors of Sibiu are Rimnicu Vilcea and Fagaras, with costs 80 and 99 respectively. The least-cost node, Rimnicu Vilcea, is expanded 
189. replace that frontier node with child Figure 3.14 Uniform-cost search on a graph. The algorithm is identical to the general graph search algorithm in Figure 3.7, except for the use of a priority queue and the addition of an extra check in case a shorter path is discovered to a frontier state. The data structure for explored needs to support efficient membership testing, so it should combine the capabilities of a priority queue and a hash table. 
190. Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 86 Chapter 3. Solving Problems by Searching DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
191. next, adding Pitesti with cost 80+97 = 177. The least-cost node is now Fagaras, so it is expanded, adding Bucharest with cost 99+211 = 310. Now a goal node has been generated, but uniform-cost search keeps going, choosing Pitesti for expansion and adding a second path to Bucharest with cost 80+97+101 = 278.
192.  Now the algorithm checks to see if this new path is better than the old one; it is, so the old one is discarded. Bucharest, now with g-cost 278, is selected for expansion and the solution is returned. .
198. 6 NoOp, or “no operation,” is the name of an assembly language instruction that does nothing. AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE Figure 3.15 A portion of the Romania state space, selected to illustrate uniform-cost search. 
199. Sibiu 99 Fagaras 80 Rimnicu Vilcea 97 Pitesti 211 101 Bucharest Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
200. Section 3.4. Uninformed Search Strategies 87 3.4.3 Depth-first search Depth-first search always expands the deepest node in the current frontier of the search tree. DEPTH-FIRST SEARCH The progress of the search is illustrated in Figure 3.16. The search proceeds immediately to the deepest level of the search tree, where the nodes have no successors.
201.  As those nodes are expanded, they are dropped from the frontier, so then the search “backs up” to the next deepest node that still has unexplored successors. .
202. The depth-first search algorithm is an instance of the graph search algorithm in Fig- ure 3.7; whereas breadth-first-search uses a FIFO queue, depth-first search uses a LIFO queue. A LIFO queue means that the most recently generated node is chosen for expansion. This must be the deepest unexpanded node, because it is one deeper that its parent—which, in turn, was the deepest unexpanded node when it was selected. 
203. As an alternative to the GRAPH-SEARCH-style implementation, it is common to im- plement depth-first search with a recursive function that calls itself on each of its children in turn. (A recursive depth-first algorithm incorporating a depth limit is shown in Figure 3.17.) 
204. AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE Figure 3.16 Depth-first search on a binary tree. The unexplored region is shown in light gray. Explored nodes with no descendants in the frontier are removed from memory. Nodes at depth 3 have no successors, and M is the only goal node. 
205. A B C D E F G H I J K L M N O A B C D E F G H I J K L M N O A C E F G J K L M N O 
206. A C F G L M N O A B C D E F G H I J K L M N O A B C D E F G I J K L M N O A B C 
207. E F G K L M N O A C F G L M N O A A B C B C D E F G D E F G H I J K L M N O H I J K L M N O 
208. A A C C E F G E F G J K L M N O J K L M N O A A C C F G F G M N O M N O C C F G 
209. F G L M N O L M N O Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 88 Chapter 3. Solving Problems by Searching The properties of depth-first search depend strongly on whether the graph search or tree search version is used.
210.  The graph search version, which avoids repeated states and redundant paths, is complete in finite state spaces because it will eventually expand every node. The tree search version, on the other hand, is not complete—for example, in Figure 3.6 the algorithm will follow the Arad–Sibiu–Arad–Sibiu loop forever.
211.  Depth-first tree search can be modified at no extra memory cost so that it checks new states against those on the path from the root to the current node; this avoids infinite loops in finite state spaces, but does not avoid the proliferation of redundant paths.
212.  In infinite state spaces, both versions fail if an infinite non- goal path is encountered. For example, in Knuth’s 4 problem, depth-first search would keep applying the factorial operator forever. .
213. For similar reasons, both versions are non-optimal. For example, in Figure 3.16, depth- first search will explore the entire left subtree even if node C is a goal node. If node J were also a goal node, then depth-first search would return it as a solution instead of C, which would be a better solution; hence, depth-first search is not optimal. 
214. The time complexity of depth-first graph search is bounded by the size of the state space (which may be infinite, of course). A depth-first tree search, on the other hand, may generate all of the O(bm) nodes in the search tree, where m is the maximum depth of any node; this can be much greater than the size of the state space.
215.  Note that m itself can be much larger than d (the depth of the shallowest solution), and is infinite if the tree is unbounded. .
216. So far depth-first search seems to have no clear advantage over breadth-first search, so why do we include it? The reason is the space complexity. For a graph search, there is no advantage, but a depth-first tree search needs to store only a single path from the root to a leaf node, along with the remaining unexpanded sibling nodes for each node on the path.
217.  Once a node has been expanded, it can be removed from memory as soon as all its descendants have been fully explored. (See Figure 3.16.) For a state space with branching factor b and maximum depth m, depth-first search requires storage of only O(bm) nodes.
218.  Using the same assumptions as Figure 3.13, and assuming that nodes at the same depth as the goal node have no successors, we find that depth-first search would require 156 kilobytes instead of 10 exabytes at depth d = 16, a factor of 7 trillion times less space.
219.  This has led to the adoption of depth-first tree search as the basic workhorse of many areas of AI, including constraint satisfaction (Chapter 6), propositional satisfiability (Chapter 7), and logic programming (Chapter 9). For the remainder of this chapter, we will focus primarily on the tree search version of depth-first search.
220.  BACKTRACKING SEARCH A variant of depth-first search called backtracking search uses still less memory. (See Chapter 6 for more details.) In backtracking, only one successor is generated at a time rather than all successors; each partially expanded node remembers which successor to generate next.
221.  In this way, only O(m) memory is needed rather than O(bm). Backtracking search facilitates yet another memory-saving (and time-saving) trick: the idea of generating a suc- cessor by modifying the current state description directly rather than copying it first. This reduces the memory requirements to just one state description and O(m) actions.
222.  For this to work, we must be able to undo each modification when we go back to generate the next suc- cessor. For problems with large state descriptions, such as robotic assembly, these techniques are critical to success. .
223. AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
224. DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. Section 3.4. Uninformed Search Strategies 89 3.4.4 Depth-limited search The embarrassing failure of depth-first search in infinite state spaces can be alleviated by supplying depth-first search with a predetermined depth limit l. That is, nodes at depth l are treated as if they have no successors. This approach is called depth-limited search. The DEPTH-LIMITED SEARCH depth limit solves the infinite-path problem.
226. Sometimes, depth limits can be based on knowledge of the problem. For example, on the map of Romania there are 20 cities. Therefore, we know that if there is a solution, it must be of length 19 at the longest, so l = 19 is a possible choice. But in fact if we studied the map carefully, we would discover that any city can be reached from any other city in at most 9 steps.
227.  This number, known as the diameter of the state space, gives us a better depth limit, DIAMETER which leads to a more efficient depth-limited search. For most problems, however, we will not know a good depth limit until we have solved the problem. .
228. Depth-limited search can be implemented as a simple modification to the general tree or graph search algorithm. Alternatively, it can be implemented as a simple recursive algorithm as shown in Figure 3.17. Notice that depth-limited search can terminate with two kinds of failure: the standard failure value indicates no solution; the cutoff value indicates no solution within the depth limit. 
229. 3.4.5 Iterative deepening depth-first search Iterative deepening search (or iterative deepening depth-first search) is a general strategy, ITERATIVE DEEPENING SEARCH often used in combination with depth-first tree search, that finds the best depth limit. It does AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE 
232. 90 Chapter 3. Solving Problems by Searching this by gradually increasing the limit—first 0, then 1, then 2, and so on—until a goal is found. This will occur when the depth limit reaches d, the depth of the shallowest goal node. The algorithm is shown in Figure 3.18. Iterative deepening combines the benefits of depth-first and breadth-first search. Like depth-first search, its memory requirements are very modest: O(bd) to be precise.
233.  Like breadth-first search, it is complete when the branching factor is finite and optimal when the path cost is a nondecreasing function of the depth of the node. Figure 3.19 shows four iterations of ITERATIVE-DEEPENING-SEARCH on a binary search tree, where the solution is found on the fourth iteration. .
234. Iterative deepening search may seem wasteful, because states are generated multiple times. It turns out this is not very costly. The reason is that in a search tree with the same (or nearly the same) branching factor at each level, most of the nodes are in the bottom level, so it does not matter much that the upper levels are generated multiple times.
235.  In an iterative deepening search, the nodes on the bottom level (depth d) are generated once, those on the next to bottom level are generated twice, and so on, up to the children of the root, which are generated d times. So the total number of nodes generated in the worst case is .
237. N(IDS) = 50+400+3,000 + 20,000 + 100,000 = 123,450 N(BFS) = 10+100+1,000 + 10,000 + 100,000 = 111,110 . In general, iterative deepening is the preferred uninformed search method when there is a large search space and the depth of the solution is not known. 
238. Iterative deepening search is analogous to breadth-first search in that it explores a com- plete layer of new nodes at each iteration before going on to the next layer. It would seem worthwhile to develop an iterative analog to uniform-cost search, inheriting the latter algo- rithm’s optimality guarantees while avoiding its memory requirements.
239.  The idea is to use increasing path-cost limits instead of increasing depth limits. The resulting algorithm, called ITERATIVE LENGTHENING SEARCH iterative lengthening search, is explored in Exercise 3.24. It turns out, unfortunately, that iterative lengthening incurs substantial overhead compared to uniform-cost search. .
240. DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE function ITERATIVE-DEEPENING-SEARCH(problem) returns a solution, or failure 
242. Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. Section 3.4. Uninformed Search Strategies 91 
243. 3.4.6 Bidirectional search The idea behind bidirectional search is to run two simultaneous searches—one forward from the initial state and the other backward from the goal—stopping when the two searches meet in the middle (Figure 3.20). The motivation is that bd/2 + bd/2 is much less than bd, or in the figure, the area of the two small circles is less than the area of one big circle centered on the start and reaching to the goal. 
244. Bidirectional search is implemented by replacing the goal test with a check to see whether the frontiers of the two searches intersect; if they do, a solution has been found. The check can be done when each node is generated or selected for expansion, and with a hash table the check will take constant time.
245.  For example, if a problem has solution depth d=6, and each direction runs breadth-first search one node at a time, then in the worst case the two .
246. AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE Limit = 0 A A Limit = 1 A A A B C B C A A A B C B C A A A A B C B C 
247. B C Limit = 2 Limit = 3 A A A A A A A A A A A A A A A A A A A A Figure 3.19 Four iterations of iterative deepening search on a binary tree. 
248. B C D E F G B C B C B C B C B C B C D E F G D E F G D E F G D E F G D E F G D E F G 
249. A B C D E F G A A A A A A B C B C B C B C B C B C D E F G D E F G D E F G D E F G 
250. D E F G D E F G B C B C B C B C B C B C B C D E F G D E F G D E F G D E F G D E F G 
251. D E F G D E F G H I J K L M N O H I J K L M N O H I J K L M N O H I J K L M N O 
252. H I J K L M N O H I J K L M N O H I J K L M N O A A A A A A A B C B C B C B C B C 
253. B C B C D E F G D E F G D E F G D E F G D E F G D E F G D E F G H I J K L M N O 
254. H I J K L M N O H I J K L M N O H I J K L M N O H I J K L M N O H I J K L M N O 
255. H I J K L M N O A A A A A A A B C B C B C B C B C B C B C D E F G D E F G D E F G 
256. D E F G D E F G D E F G D E F G H I J K L M N O H I J K L M N O H I J K L M N O 
257. H I J K L M N O H I J K L M N O H I J K L M N O H I J K L M N O Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
258. 92 Chapter 3. Solving Problems by Searching searches meet when they have generated all of the nodes at depth 3. For b= 10, this means a total of 2,220 node generations, compared with 1,111,110 for a standard breadth-first search. Thus, the time complexity of bidirectional search using breadth-first searches in both direc- tions is O(bd/2). The space complexity is also O(bd/2). We can reduce this by roughly half if one of the two searches is done using iterative deepening, but at least one of the frontiers must be kept in memory so that the intersection check can be done.
259.  This space requirement is the most significant weakness of bidirectional search. The algorithm is complete and optimal (for uniform step costs) if both searches are breadth-first; other combinations may sacrifice completeness, optimality, or both. .
260. The reduction in time complexity makes bidirectional search attractive, but how do we PREDECESSORS search backward? This is not as easy as it sounds. Let the predecessors of a state x be all those states that have x as a successor. Bidirectional search requires a method for computing predecessors.
261.  The easiest case is when all the actions in the state space are reversible, so that the predecessors of x are the same as its successors. Other cases may require substantial ingenuity. .
262. Consider the question of what we mean by “the goal” in searching “backward from the goal.” For the 8-puzzle and for finding a route in Romania, there is just one goal state, so the backward search is very much like the forward search. If there are several explicitly listed goal states—for example, the two dirt-free goal states in Figure 3.3—then we can construct a new dummy goal state whose immediate predecessors are all the actual goal states.
263.  Alternatively, some redundant node generations can be avoided by viewing the set of goal states as a single state, each of whose predecessors is also a set of states—specifically, the set of states having a corresponding successor in the set of goal states. (See also Section 4.3.) .
264. The most difficult case for bidirectional search is when the goal test gives only an im- plicit description of some possibly large set of goal states—for example, all the states that are solutions to the n-queens problem. A backward search would need to construct compact descriptions of “all states that are one queen away from being solutions” and so on; and those descriptions would have to be tested against the states generated by the forward search.
265.  There is no general way to do this efficiently. .
266. AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. Figure 3.20 A schematic view of a bidirectional search that is about to succeed, when a branch from the start node meets a branch from the goal node. 
267. Goal Start Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
268. Section 3.5. Informed (Heuristic) Search Strategies 93 This section shows how aninformed search strategy—one that uses problem-specific knowl- INFORMED SEARCH edge beyond the definition of the problem itself—can find solutions more efficiently than an uninformed strategy. The general approach we will consider is called best-first search. Best-first search is BEST-FIRST SEARCH an instance of the general TREE-SEARCH or GRAPH-SEARCH algorithm in which a node is selected for expansion based on an evaluation function, f(n).
269.  The evaluation function is EVALUATION FUNCTION construed as a cost estimate, so the node with the lowest evaluation is expanded first. The implementation of best-first search is identical to that for uniform-cost search (Figure 3.14), except for the use of f instead of g to order the priority queue. .
270. The choice of f determines the search strategy. (In fact, as Exercise 3.33 shows, best- first search includes breadth-first, depth-first, and uniform-cost search as special cases.) Most best-first algorithms include as a component of f a heuristic function, denoted h(n): HEURISTIC FUNCTION 
271. h(n) = estimated cost of the cheapest path from the state at node n to a goal state. (Notice that h(n) takes a node as input, but, unlike g(n), it depends only on the state at that node.) For example, in Romania, one might estimate the cost of the cheapest path from Arad to Bucharest via the straight-line distance from Arad to Bucharest. 
272. Heuristic functions are the most common form in which additional knowledge of the problem is imparted to the search algorithm. We will study heuristics in more depth in Sec- tion 3.6. For now, we will consider them to be arbitrary, non-negative, problem-specific 
273. AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE 3.5 INFORMED (HEURISTIC) SEARCH STRATEGIES 3.4.7 Comparing uninformed search strategies Figure 3.21 compares search strategies in terms of the four evaluation criteria set forth in Section 3.4. This comparison is for tree-search versions. For graph searches, the main dif- ferences are that depth-first search is complete for finite state spaces, and that the space and time complexities are bounded by the size of the state space. 
276. Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 94 Chapter 3. Solving Problems by Searching functions, with one constraint: if n is a goal node, then h(n)=0. The remainder of this section covers two ways to use heuristic information to guide search. 
277. 3.5.1 Greedy best-first search GREEDY BEST-FIRST SEARCH Greedy best-first search7 tries to expand the node that is closest to the goal, on the grounds that this is likely to lead to a solution quickly. Thus, it evaluates nodes by using just the 
278. heuristic function: f(n) = h(n). Let us see how this works for route-finding problems in Romania, using the straight- STRAIGHT-LINE DISTANCE line distance heuristic, which we will call hSLD. If the goal is Bucharest, we will need to know the straight-line distances to Bucharest, which are shown in Figure 3.
279. 22. For example, hSLD(In(Arad)) = 366. Notice that the values of hSLD cannot be computed from the prob- lem description itself. Moreover, it takes a certain amount of experience to know that hSLD is correlated with actual road distances and is, therefore, a useful heuristic. .
280. DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. Figure 3.23 shows the progress of a greedy best-first search using hSLD to find a path from Arad to Bucharest.
281.  The first node to be expanded from Arad will be Sibiu, because it is closer to Bucharest than either Zerind or Timisoara. The next node to be expanded will be Fagaras, because it is closest. Fagaras in turn generates Bucharest, which is the goal.
282.  For this particular problem, greedy best-first search using hSLD finds a solution without ever expanding a node that is not on the solution path; hence, its search cost is minimal. It is not optimal, however: the path via Sibiu and Fagaras to Bucharest is 32 kilometers longer than the path through Rimnicu Vilcea and Pitesti.
283.  This shows why the algorithm is called “greedy”—at each step it tries to get as close to the goal as it can. .
284. Greedy best-first tree search is also incomplete even in a finite state space, much like depth-first search. Consider the problem of getting from Iasi to Fagaras. The heuristic sug- gests that Neamt be expanded first, because it is closest to Fagaras, but it is a dead end. The solution is to go first to Vaslui—a step that is actually farther from the goal according to the heuristic—and then to continue to Urziceni, Bucharest, and Fagaras.
285.  The algorithm will never find this solution, however, because expanding Neamt puts Iasi back into the frontier, .
286. 7 Our first edition called this greedy search; other authors have called it best-first search. Our more general usage of the latter term follows Pearl (1984). AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE Figure 3.22 Values of hSLD—straight-line distances to Bucharest. 
287. Arad Bucharest Craiova Drobeta Eforie Fagaras Giurgiu Hirsova Iasi Lugoj 366 0 160 242 161176 77 151 226 244 Mehadia Neamt Oradea Pitesti Rimnicu Vilcea Sibiu Timisoara Urziceni Vaslui Zerind Mehadia Neamt Oradea Pitesti Rimnicu Vilcea Sibiu Timisoara Urziceni Vaslui Zerind 
288. 241 234 380 100 193 253 32980 199 374 241 234 380 100 193 253 32980 199 374 241 234 380 100 193 253 32980 199 374 Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
289. Section 3.5. Informed (Heuristic) Search Strategies 95 Iasi is closer to Fagaras than Vaslui is, and so Iasi will be expanded again, leading to an infi- nite loop. (The graph search version is complete in finite spaces, but not in infinite ones.) The worst-case time and space complexity for the tree version is O(bm), where m is the maximum depth of the search space.
290.  With a good heuristic function, however, the complexity can be reduced substantially. The amount of the reduction depends on the particular problem and on the quality of the heuristic. .
292. AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE (a) The initial state (b) After expanding Arad (c) After expanding Sibiu (d) After expanding Fagaras Arad Sibiu Arad Fagaras Oradea Arad Arad Arad Zerind Timisoara Rimnicu Vilcea Figure 3.23 Stages in a greedy best-first tree search for Bucharest using the straight-line distance heuristic hSLD. Nodes are labeled with their h-values. 
293. 366 Sibiu Timisoara Zerind 253 329 374 Sibiu Arad Fagaras Oradea Timisoara 329 Zerind Zerind 374 Rimnicu Vilcea 366 176 380 193 Sibiu Bucharest 329 374 366 380 193 253 0 Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
294. 96 Chapter 3. Solving Problems by Searching to get from the node to the goal: f(n) = g(n) + h(n) . Since g(n) gives the path cost from the start node to node n, and h(n) is the estimated cost of the cheapest path from n to the goal, we have 
297. Conditions for optimality: Admissibility and consistency ADMISSIBLE HEURISTIC The first condition we require for optimality is that h(n) be an admissible heuristic. An admissible heuristic is one that never overestimates the cost to reach the goal. Because g(n) is the actual cost to reach n, and f(n)=g(n) + h(n), we have as immediate consequence that f(n) never overestimates the true cost of a solution through n. 
298. Admissible heuristics are by nature optimistic, because they think the cost of solving the problem is less than it actually is. An obvious example of an admissible heuristic is the straight-line distance hSLD that we used in getting to Bucharest. Straight-line distance is admissible because the shortest path between any two points is a straight line, so the straight line cannot be an overestimate.
300.  Another way to say this is that there might be a solution through Pitesti whose cost is as low as 417, so the algorithm will not settle for a solution that costs 450. .
304. It is fairly easy to show (Exercise 3.37) that every consistent heuristic is also admissible. Consistency is therefore a stricter requirement than admissibility, but one has to work quite hard to concoct heuristics that are admissible but not consistent. All the admissible heuristics we discuss in this chapter are also consistent. Consider, for example, hSLD. We know that 
305. AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
307. AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE (a) The initial state (b) After expanding Arad (c) After expanding Sibiu Arad 366=0+366 (d) After expanding Rimnicu Vilcea (e) After expanding Fagaras (f) After expanding Pitesti Arad Sibiu Timisoara 
308. 447=118+329 Zerind 393=140+253 449=75+374 Arad Sibiu Arad Timisoara Fagaras Oradea Rimnicu Vilcea Zerind 447=118+329 449=75+374 646=280+366 415=239+176 671=291+380 413=220+193 Arad Sibiu Timisoara Zerind 447=118+329 449=75+374 Arad Fagaras Oradea Rimnicu Vilcea 646=280+366 415=239+176 671=291+380 Craiova Pitesti Sibiu 526=366+160 417=317+100 553=300+253 Arad 
309. Sibiu Zerind Arad Timisoara Sibiu Bucharest 447=118+329 449=75+374 Fagaras Oradea Rimnicu Vilcea 646=280+366 671=291+380 Craiova Pitesti Sibiu 591=338+253 450=450+0 526=366+160 417=317+100 553=300+253 Arad Sibiu Zerind Arad Fagaras Rimnicu Vilcea Timisoara Oradea Sibiu BucharestCraiova Pitesti Sibiu Bucharest Craiova Rimnicu Vilcea 418=418+0 
319. DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
326. In the general case of a graph, the situation is even worse: there can be exponentially AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE Figure 3.25 Map of Romania showing contours at f = 380, f = 400 and f = 420, with Arad as the start state. Nodes inside a given contour have f-costs less than or equal to the contour value. 
327. O Z AT N 380 S F400 S F400 R I V V LM D C P 420 G B U HE B U HE B U HE Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
334.  RECURSIVE BEST-FIRST SEARCH Recursive best-first search (RBFS) is a simple recursive algorithm that attempts to mimic the operation of standard best-first search, but using only linear space. The algorithm is shown in Figure 3.26. Its structure is similar to that of a recursive depth-first search, but rather than continuing indefinitely down the current path, it uses the f .
335. limit variable to keep track of the f-value of the best alternative path available from any ancestor of the current node. If the current node exceeds this limit, the recursion unwinds back to the alternative path. As the recursion unwinds, RBFS replaces the f-value of each node along the path 
337.  In the example in Figure 3.27, RBFS first follows the path via Rimnicu Vilcea, then “changes its mind” and tries Fagaras, and then changes its mind back again. These mind changes occur because every time the current best path is extended, there is a good chance .
338. AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
339. DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. Section 3.5. Informed (Heuristic) Search Strategies 101 that its f-value will increase—h is usually less optimistic for nodes closer to the goal. When this happens, particularly in large search spaces, the second-best path might become the best path, so the search has to backtrack to follow it.
343.  Because they forget most of that they have done, both algorithms may end up reex- panding the same states many times over. Furthermore, they suffer the potentially exponential increase in complexity associated with redundant paths in graphs (see Section 3.3). .
349. 102 Chapter 3. Solving Problems by Searching DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. the path it has forgotten. Another way of saying this is that, if all the descendants of a node n are forgotten, then we will not know which way to go from n, but we will still have an idea of how worthwhile it is to go anywhere from n.
350. AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE Figure 3.27 Stages in an RBFS search for the shortest route to Bucharest. The f-limit value for each recursive call is shown on top of each current node, and every node is labeled with its f-cost. (a) The path via Rimnicu Vilcea is followed until the current best leaf (Pitesti) has a value that is worse than the best alternative path (Fagaras). (b) The recursion unwinds and the best leaf value of the forgotten subtree (417) is backed up to Rimnicu Vilcea; then Fagaras is expanded, revealing a best leaf value of 450.
351.  (c) The recursion unwinds and the best leaf value of the forgotten subtree (450) is backed up to Fagaras; then Rimnicu Vilcea is expanded. This time, because the best alternative path (through Timisoara) costs at least 447, the expansion continues to Bucharest. .
354. 366 Sibiu 393 447 Zerind 449 Arad 646 Fagaras 415 450 Oradea 671 Rimnicu Vilcea 417 Craiova Pitesti Sibiu 526 553 Bucharest Craiova Rimnicu Vilcea 418 615 607 Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
355. DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. Section 3.5. Informed (Heuristic) Search Strategies 103 The complete algorithm is too complicated to reproduce here,8 but there is one subtlety worth mentioning.
357.  These coincide when there is only one leaf, but in that case, the current search tree must be a single path from root to leaf that fills all of memory. If the leaf is not a goal node, then even if it is on an optimal solution path, that solution is not reachable with the available memory.
358.  Therefore, the node can be discarded exactly as if it had no successors. .
361.  That is to say, memory limitations can make a problem intractable from the point of view of computation time. Although there is no theory to explain the tradeoff between time and memory, it seems that this is an inescapable problem. The only way out is to drop the optimality requirement. .
362. 3.5.4 Learning to search better We have presented several fixed strategies—breadth-first, greedy best-first, and so on—that have been designed by computer scientists. Could an agent learn how to search better? The answer is yes, and the method rests on an important concept called the metalevel state space.
365. Now, the path in Figure 3.24 has five steps, including one step, the expansion of Fagaras, that is not especially helpful. For harder problems, there will be many such missteps, and a metalevel learning algorithm can learn from these experiences to avoid exploring unpromis- METALEVEL LEARNING ing subtrees.
366.  The techniques used for this kind of learning are described in Chapter 21. The goal of learning is to minimize the total cost of problem solving, trading off computational expense and path cost. .
367. 8 A rough sketch appeared in the first edition of this book. AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 104 Chapter 3. Solving Problems by Searching 
368. 3.6 HEURISTIC FUNCTIONS The average solution cost for a randomly generated 8-puzzle instance is about 22 steps. The branching factor is about 3. (When the empty tile is in the middle, there are four possible moves; when it is in a corner there are two; and when it is along an edge there are three.
371.  There is a long history of such heuristics for the 15-puzzle; here are two commonly used candidates: .
372. • h1 = the number of misplaced tiles. For Figure 3.28, all of the eight tiles are out of position, so the start state would have h1 = 8. h1 is an admissible heuristic, because it is clear that any tile that is out of place must be moved at least once. 
373. • h2 = the sum of the distances of the tiles from their goal positions. Because tiles cannot move along diagonals, the distance we will count is the sum of the horizontal and vertical distances. This is sometimes called the city block distance or Manhattan MANHATTAN DISTANCE distance.
374.  h2 is also admissible, because all any move can do is move one tile one step closer to the goal. Tiles 1 to 8 in the start state give a Manhattan distance of .
375. h2 =3+1+2+2+2+3+3+2=18 . As expected, neither of these overestimates the true solution cost, which is 26. AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
376. In this section, we will look at heuristics for the 8-puzzle, in order to shed light on the nature of heuristics in general. The 8-puzzle was one of the earliest heuristic search problems. As mentioned in Sec- tion 3.2, the object of the puzzle is to slide the tiles horizontally or vertically into the empty space until the configuration matches the goal configuration (Figure 3.28). 
377. Figure 3.28 A typical instance of the 8-puzzle. The solution is 26 steps long. 4721 2 5 6 3 4 3 4 83 6 7 8 8 5 5 5 1 1 1 Start State Goal State Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
387. IDS IDS 2.79 2.79 2.79 2.79 2.45 2.45 2.45 2.45 2.87 2.87 2.87 2.87 2.73 2.73 2.73 2.73 2.80 2.80 2.80 2.80 2.78 2.78 2.78 2.78 – – – – – – – – – – – – – – 
391. 1.23 1.23 1.23 1.25 1.25 1.25 1.25 1.25 1.25 1.26 1.26 1.26 1.26 1.26 1.26 1.27 1.27 1.27 1.27 1.27 1.27 1.28 1.28 1.28 1.28 1.28 1.28 1.26 1.26 1.26 1.26 1.26 1.26 Search Cost (nodes generated) Effective Branching Factor 
394. 3.6.2 Generating admissible heuristics from relaxed problems We have seen that both h1 (misplaced tiles) and h2 (Manhattan distance) are fairly good heuristics for the 8-puzzle and that h2 is better. How might one have come up with h2? Is it possible for a computer to invent such a heuristic mechanically? 
395. h1 and h2 are estimates of the remaining path length for the 8-puzzle, but they are also perfectly accurate path lengths for simplified versions of the puzzle. If the rules of the puzzle were changed so that a tile could move anywhere, instead of just to the adjacent empty square, then h1 would give the exact number of steps in the shortest solution.
396.  Similarly, if a tile could move one square in any direction, even onto an occupied square, then h2 would give the exact number of steps in the shortest solution. A problem with fewer restrictions on the actions is .
397. RELAXED PROBLEM called a relaxed problem. The state-space graph of the relaxed problem is a supergraph of the original state space, because the removal of restrictions creates added edges in the graph. Because the relaxed problem adds edges to the state space, any optimal solution in the original problem is, by definition, also a solution in the relaxed problem; but the relaxed problem may have better solutions if the added edges provide short cuts.
398.  Hence, the cost of an optimal solution to a relaxed problem is an admissible heuristic for the original problem. Furthermore, because the derived heuristic is an exact cost for the relaxed problem, it must obey the triangle inequality and is therefore consistent (see page 96). .
399. If a problem definition is written down in a formal language, it is possible to construct relaxed problems automatically.9 For example, if the 8-puzzle actions are described as A tile can move from square A to square B if A is horizontally or vertically adjacent to B and B is blank, we can generate three relaxed problems by removing one or both of the conditions: 
400. (a) A tile can move from square A to square B if A is adjacent to B. (b) A tile can move from square A to square B if B is blank. (c) A tile can move from square A to square B. 
401. From (a), we can derive h2 (Manhattan distance). The reasoning is that h2 would be the proper score if we moved each tile in turn to its destination. The heuristic derived from (b) is discussed in Exercise 3.39. From (c), we can derive h1 (misplaced tiles), because it would be the proper score if tiles could move to their intended destination in one step. Notice that it is 
402. DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 9 In Chapters 8 and 11, we will describe formal languages suitable for this task; with formal descriptions that can be manipulated, the construction of relaxed problems can be automated. For now, we will use English. 
403. AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
404. Section 3.6. Heuristic Functions 107 crucial that the relaxed problems generated by this technique can be solved essentially without search, because the relaxed rules allow the problem to be decomposed into eight independent subproblems. If the relaxed problem is hard to solve, then the values of the corresponding heuristic will be expensive to obtain.10 
405. A program called ABSOLVER can generate heuristics automatically from problem def- initions, using the “relaxed problem” method and various other techniques (Prieditis, 1993). ABSOLVER generated a new heuristic for the 8-puzzle that was better than any preexisting heuristic and found the first useful heuristic for the famous Rubik’s cube puzzle. 
406. One problem with generating new heuristic functions is that one often fails to get one “clearly best” heuristic. If a collection of admissible heuristics h1 ...hm is available for a problem, and none of them dominates any of the others, which should we choose? As it turns out, we need not make a choice. We can have the best of all worlds, by defining 
407. h(n) = max{h1(n),...,hm(n)} . This composite heuristic uses whichever function is most accurate on the node in question. Because the component heuristics are admissible, h is admissible; it is also easy to prove that h is consistent. Furthermore, h dominates all of its component heuristics. 
408. 3.6.3 Generating admissible heuristics from subproblems: Pattern databases Admissible heuristics can also be derived from the solution cost of a subproblem of a given SUBPROBLEM problem. For example, Figure 3.30 shows a subproblem of the 8-puzzle instance in Fig- ure 3.28. The subproblem involves getting tiles 1, 2, 3, 4 into their correct positions. Clearly, the cost of the optimal solution of this subproblem is a lower bound on the cost of the com- plete problem.
409.  It turns out to be substantially more accurate than Manhattan distance in some cases.The idea behind pattern databases is to store these exact solution costs for every pos- PATTERN DATABASES sible subproblem instance—in our example, every possible configuration of the four tiles and the blank. (Notice that the locations of the other four tiles are irrelevant for the purposes of .
410. 10 Note that a perfect heuristic can be obtained simply by allowing h to run a full breadth-first search “on the sly.” Thus, there is a tradeoff between accuracy and computation time for heuristic functions. AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE 
411. Figure 3.30 A subproblem of the 8-puzzle instance given in Figure 3.28. The task is to get tiles 1, 2, 3, and 4 into their correct positions, without worrying about what happens to the other tiles. 23 45 6 821 
412. 3 6 7 854 1 Start State Goal State Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 108 Chapter 3. Solving Problems by Searching solving the subproblem, but moves of those tiles do count towards the cost.) Then we com- pute an admissible heuristic hDB for each complete state encountered during a search simply by looking up the corresponding subproblem configuration in the database.
413.  The database itself is constructed by searching backward11 from the goal state and recording the cost of each new pattern encountered; the expense of this search is amortized over many subsequent problem instances. .
414. The choice of 1-2-3-4 is fairly arbitrary; we could also construct databases for 5-6-7-8, for 2-4-6-8, and so on. Each database yields an admissible heuristic, and these heuristics can be combined, as explained earlier, by taking the maximum value. A combined heuristic of this kind is much more accurate than the Manhattan distance; the number of nodes generated when solving random 15-puzzles can be reduced by a factor of 1000. 
415. One might wonder whether the heuristics obtained from the 1-2-3-4 database and the 5-6-7-8 could be added, since the two subproblems seem not to overlap. Would this still give an admissible heuristic? The answer is no, because the solutions of the 1-2-3-4 subproblem and the 5-6-7-8 subproblem for a given state will almost certainly share some moves—it is unlikely that 1-2-3-4 can be moved into place without touching 5-6-7-8, and vice versa.
416.  But what if we don’t count those moves? That is, we record not the total cost of solving the 1-2-3-4 subproblem, but just the number of moves involving 1-2-3-4. Then it is easy to see that the sum of the two costs is still a lower bound on the cost of solving the entire problem.
417.  DISJOINT PATTERN DATABASES This is the idea behind disjoint pattern databases. Using such databases, it is possible to solve random 15-puzzles in a few milliseconds—the number of nodes generated is reduced by a factor of 10,000 compared with using Manhattan distance. For 24-puzzles, a speedup of roughly a million can be obtained.
418. Disjoint pattern databases work for sliding-tile puzzles because the problem can be divided up in such a way that each move affects only one subproblem—because only one tile is moved at a time. For a problem such as Rubik’s cube, this kind of subdivision cannot be done because each move affects 8 or 9 of the 26 cubies. Currently, it is not clear how to define disjoint databases for such problems. 
419. 3.6.4 Learning heuristics from experience A heuristic function h(n) is supposed to estimate the cost of a solution beginning from the state at node n. How could an agent construct such a function? One solution was given in the preceding sections—namely, to devise relaxed problems for which an optimal solution can be found easily. Another solution is to learn from experience. “Experience” here means solving lots of 8-puzzles, for instance. Each optimal solution to an 8-puzzle problem provides examples from which h(n) can be learned.
420.  Each example consists of a state from the solu- tion path and the actual cost of the solution from that point. From these examples, a learning algorithm can be used to construct a function h(n) that can (with luck) predict solution costs for other states that arise during search. Techniques for doing just this using neural nets, de- .
421. DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 11 By working backward from the goal, the exact solution cost of every instance encountered is immediately available with no further computation. This is an example of dynamic programming, which we discuss further in Chapter 17. 
422. AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
423. Section 3.7. Summary 109 cision trees, and other methods are demonstrated in Chapter 18. (The reinforcement learning methods described in Chapter 21 are also applicable.) Inductive learning methods work best when supplied with features of a state that are FEATURES relevant to predicting the state’s value, rather than with just the raw state description.
424.  For example, the feature “number of misplaced tiles” might be helpful in predicting the actual distance of a state from the goal. Let’s call this feature x1(n). We could take 100 randomly generated 8-puzzle configurations and gather statistics on their actual solution costs. We might find that when x1(n) is 5, the average solution cost is around 14, and so on.
425.  Given these data, the value of x1 can be used to predict h(n). Of course, we can use several features. A second feature x2(n) might be “number of pairs of adjacent tiles that are not adjacent in the goal state.” How should x1(n) and x2(n) be combined to predict h(n)? A common approach is to use a linear combination: .
426. h(n) = c1x1(n) + c2x2(n) . The constants c1 and c2 are adjusted to give the best fit to the actual data on solution costs. One expects both c1 and c2 to be positive, because misplaced tiles and incorrect adjacent pairs make the problem harder to solve. Notice that this heuristic does satisfy the condition that h(n)=0 for goal states, but it is not necessarily admissible or consistent. 
427. 3.7 SUMMARY This chapter has introduced methods that an agent can use to select actions in environments that are deterministic, observable, static, and completely known. In such cases, the agent can construct sequences of actions that achieve its goals; this process is called search. 
428. • Before an agent can start searching for solutions, a goal must be identified and a well- defined problem must be formulated. • A problem consists of five parts: the initial state, a set of actions, a transition model describing the results of those actions, a goal test function, and a path cost function.
429.  The environment of the problem is represented by a state space. A path through the state space from the initial state to a goal state is a solution. .
430. • Search algorithms treat states and actions as atomic: they do not consider any internal structure they might possess. • A general TREE-SEARCH algorithm considers all possible paths to find a solution, while a GRAPH-SEARCH algorithm avoids consideration of redundant paths. 
431. • Search algorithms are judged on the basis of completeness, optimality, time complex- ity, and space complexity. Complexity depends on b, the branching factor in the state space, and d, the depth of the shallowest solution. • Uninformed search methods have access only to the problem definition. The basic algorithms are as follows: 
432. – Breadth-first search expands the shallowest nodes first; it is complete, optimal for unit step costs, but has exponential space complexity. AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
433. 110 Chapter 3. Solving Problems by Searching – Uniform-cost search expands the node with lowest path cost, g(n), and is optimal for general step costs. – Depth-first search expands the deepest unexpanded node first. It is neither com- plete nor optimal, but has linear space complexity. Depth-limited search adds a depth bound.
434.  – Iterative deepening search calls depth-first search with increasing depth limits until a goal is found. It is complete, optimal for unit step costs, has time complexity comparable to breadth-first search, and has linear space complexity. – Bidirectional search can enormously reduce time complexity, but it is not always .
435. applicable and may require too much space. • Informed search methods may have access to a heuristic function h(n) that estimates the cost of a solution from n. – The generic best-first search algorithm selects a node for expansion according to 
438. • The performance of heuristic search algorithms depends on the quality of the heuristic function. Good heuristics can sometimes be constructed by relaxing the problem defi- nition, by storing precomputed solution costs for subproblems in a pattern database, or by learning from experience with the problem class. 
439. BIBLIOGRAPHICAL AND HISTORICAL NOTES The topic of state-space search originated in more or less its current form in the early years of AI. Newell and Simon’s work on the Logic Theorist (1957) and GPS (1961) led to the estab- lishment of search algorithms as the primary weapons in the armory of 1960s AI researchers and to the establishment of problem solving as the canonical AI task.
440.  Work in operations research by Richard Bellman (1957) showed the importance of additive path costs in sim- plifying optimization algorithms. The text on Automated Problem Solving by Nils Nilsson (1971) established the area on a solid theoretical footing. .
441. Most of the state-space search problems analyzed in this chapter have a long history in the literature and are less trivial than they might seem. The missionaries and cannibals problem used in Exercise 3.22 was analyzed in detail by Amarel (1968). It had been consid- 
442. AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
443. DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. Section 3.7. Summary 111 ered earlier in AI by Simon and Newell (1961), and in operations research by Bellman and Dreyfus (1962). 
444. The 8-puzzle is a smaller cousin of the 15-puzzle, whose history is recounted at length by Slocum and Sonneveld (2006). For most of the 20th century, it was widely believed to have been invented by the famous American game designer Sam Loyd, based on his claims to that effect from 1891 onwards (Loyd, 1959). It turns out to have been invented by Noyes Chapman, a postmaster in Canastota, New York, in the mid-1870s, and achieved immense popularity in the United States and Europe.
445.  (Chapman was unable to patent his invention, as a generic patent covering sliding blocks with letters, numbers, or pictures was granted to Ernest Kinsey in 1878.) It also quickly attracted the attention of mathematicians (Johnson and Story, 1879; Tait, 1880). The editors of the American Journal of Mathematics stated, “The ‘15’ puzzle for the last few weeks has been prominently before the American public, and may safely be said to have engaged the attention of nine out of ten persons of both sexes and all ages and conditions of the community.
446.  But this would not have weighed with the editors to induce them to insert articles upon such a subject in the American Journal of Mathematics, but for the fact that ...” (there follows a summary of the mathematical interest of the 15-puzzle). An exhaustive analysis of the 8-puzzle was carried out with computer aid by Schofield (1967). Ratner and Warmuth (1986) showed that the general n × n version of the 15-puzzle belongs to the class of NP-complete problems.
447. The 8-queens problem was first published anonymously in the German chess maga- zine Schach in 1848; it was later attributed to one Max Bezzel. It was republished in 1850 and at that time drew the attention of the eminent mathematician Carl Friedrich Gauss, who attempted to enumerate all possible solutions, but found only 72. Nauck published all 92 solutions later in 1850. Netto (1901) generalized the problem to n queens, and Abramson and Yung (1989) found an O(n) algorithm. 
448. Each of the real-world search problems listed in the chapter has been the subject of a good deal of research effort. Methods for selecting optimal airline flights remain propri- etary for the most part, but Carl de Marcken (personal communication) has shown that airline ticket pricing and restrictions have become so convoluted that the problem of selecting an optimal flight is formally undecidable. The traveling-salesperson problem is a standard com- binatorial problem in theoretical computer science (Lawler, 1985; Lawler et al.
449. , 1992). Karp (1972) proved the TSP to be NP-hard, but effective heuristic approximation methods were de- veloped (Lin and Kernighan, 1973). Arora (1998) devised a fully polynomial approximation scheme for Euclidean TSPs. VLSI layout methods are surveyed by Shahookar and Mazumder (1991), and many layout optimization papers appear in VLSI journals. Robotic navigation and assembly problems are discussed in Chapter 25. .
450. Uninformed search algorithms for problem solving are a central topic of classical com- puter science (Horowitz and Sahni, 1978) and operations research (Dreyfus, 1969). Breadth- first search was formulated for solving mazes by Moore (1959). The method of dynamic programming (Bellman, 1957; Bellman and Dreyfus, 1962), which systematically records solutions for all subproblems of increasing lengths, can be seen as a form of breadth-first search on graphs.
451.  The two-point shortest-path algorithm of Dijkstra (1959) is the origin of uniform-cost search. These works also introduced the idea of explored and frontier sets .
452. AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 112 Chapter 3. Solving Problems by Searching (closed and open lists). A version of iterative deepening designed to make efficient use of the chess clock was first used by Slate and Atkin (1977) in the CHESS 4.
453. 5 game-playing program, but the appli- cation to shortest-path graph search is due to Korf (1985a). Bidirectional search, which was introduced by Pohl (1969, 1971), can also be very effective in some cases. .
454. The use of heuristic information in problem solving appears in an early paper by Simon and Newell (1958), but the phrase “heuristic search” and the use of heuristic functions that estimate the distance to the goal came somewhat later (Newell and Ernst, 1965; Lin, 1965). Doran and Michie (1966) conducted extensive experimental studies of heuristic search as applied to a number of problems, especially the 8-puzzle and the 15-puzzle. Although Doran and Michie carried out theoretical analyses of path length and “penetrance” (the ratio of path length to the total number of nodes examined so far) in heuristic search, they appear to have ignored the information provided by the path cost g(n).
462. AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
464. , 1984; Kumar et al., 1988). Martelli and Monta- nari (1978) demonstrate a connection between dynamic programming (see Chapter 17) and certain types of state-space search. Kumar and Kanal (1988) attempt a “grand unification” of heuristic search, dynamic programming, and branch-and-bound techniques under the name of CDP—the “composite decision process.” .
465. Because computers in the late 1950s and early 1960s had at most a few thousand words of main memory, memory-bounded heuristic search was an early research topic. The Graph Traverser (Doran and Michie, 1966), one of the earliest search programs, commits to an operator after searching best first up to the memory limit.
467. RBFS (Korf, 1991, 1993) is actually somewhat more complicated than the algorithm shown in Figure 3.26, which is closer to an independently developed algorithm called itera- tive expansion, or IE (Russell, 1992). RBFS uses a lower bound as well as the upper bound; ITERATIVE EXPANSION the two algorithms behave identically with admissible heuristics, but RBFS expands nodes in best-first order even with an inadmissible heuristic.
470. The idea that admissible heuristics can be derived by problem relaxation appears in the seminal paper by Held and Karp (1970), who used the minimum-spanning-tree heuristic to solve the TSP. (See Exercise 3.38.) The automation of the relaxation process was implemented successfully by Priedi- tis (1993), building on earlier work with Mostow (Mostow and Prieditis, 1989).
471.  The use of pattern databases to derive admissible heuristics is due to Gasser (1995) and Culberson and Schaeffer (1998); disjoint pattern databases are described by Korf and Felner (2002). The probabilistic interpretation of heuristics was investigated in depth by Pearl (1984) and Hansson and Mayer (1989). .
473. AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 114 Chapter 3. Solving Problems by Searching sical search algorithms. Kanal and Kumar (1988) present an anthology of important articles on heuristic search. Papers about new search algorithms—which, remarkably, continue to be discovered—appear in journals such as Artificial Intelligence and Journal of the ACM. 
474. PARALLEL SEARCH The topic of parallel search algorithms was not covered in the chapter, partly because it requires a lengthy discussion of parallel computer architectures. Parallel search became a popular topic in the 1990s in both AI and theoretical computer science (Mahanti and Daniels, 1993; Grama and Kumar, 1995; Crauser et al.
475. , 1998) and is making a comeback in the era of new multicore and cluster architectures (Ralphs et al., 2004; Korf and Schultze, 2005). Also of increasing importance are search algorithms for very large graphs that require disk storage (Korf, 2008). .
476. EXERCISES 3.1 Define in your own words the following terms: state, state space, search tree, search node, goal, action, transition model, and branching factor. 3.2 Explain why problem formulation must follow goal formulation. 3.3 Which of the following are true and which are false? Give a brief explanation for each answer. 
478. ous. d. Breadth-first search is complete even if zero step-costs are allowed. e. Assume that a rook can move on a chessboard any number of squares in a straight line, vertically or horizontally, but cannot jump over other pieces. Manhattan distance is an admissible heuristic for the problem of moving the rook from square A to square B in the smallest number of moves. 
479. 3.4 Give a complete problem formulation for each of the following problems. Choose a formulation that is precise enough to be implemented. a. There are six glass boxes in a row, each with a lock. Each of the first five boxes holds a key unlocking the next box in line, the last holds a banana.
480.  You have the key to the first box, and you want the banana. b. You start with the sequence ABABAECCEC, or in general any sequence made from A, B, C, and E. You can transform this sequence using the following equalities: AC = E, AB = BC, BB = E, and Ex = x for any x.
481.  For example, ABBC can be transformed into AEC, and then AC, and then E. Your goal is to produce the sequence E. c. There is an n by n grid of squares, each square initially being either unpainted floor or a bottomless pit.
482.  You start standing on an unpainted floor square, and can either paint .
483. AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
484. DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. Section 3.7. Summary 115 the square under you, or move onto an adjacent unpainted floor square. You want the whole floor painted. d. A container ship is in port, loaded high with containers.
485.  There 13 rows of containers, each 13 containers wide and 5 containers tall. You control a crane that can move to any location above the ship, pick up the container under it, and move it onto the dock. You want the ship unloaded. .
486. 3.5 Your goal is to navigate a robot out of a maze. The robot starts in the center of the maze facing north. You can turn the robot to face north, east, south, or west. You can direct the robot to move forward a certain distance, although it will stop before hitting a wall. 
487. a. Formulate this problem. How large is the state space? b. In navigating a maze, the only place we need to turn is at the intersection of two or more corridors. Reformulate this problem using this observation. How large is the state space now? c. From each point in the maze, we can move in any of the four directions until we reach a turning point, and this is the only action we need to do.
488.  Reformulate the problem using these actions. Do we need to keep track of the robot’s orientation now? d. In our initial description of the problem we already abstracted from the real world, restricting actions and removing irrelevant details. List three such simplifications we made. .
489. 3.6 What’s the difference between a world state, a state description, and a search node? Why is this distinction useful? 3.7 You have a 9× 9 grid of squares, each of which can be colored red or blue. The grid is initially colored all blue, but you can change the color of any square any number of times.
490.  Imagining the grid divided into nine 3×3 sub-squares, you want each sub-square to be all one color, but neighboring sub-squares to be different colors. .
491. a. Formulate this problem in the straightforward way. Compute the size of the state space. b. You need color a square only once. Reformulate, and compute the size of the state space. Would breadth-first graph search perform faster on this problem than on the one in (a)? How about iterative-deepening tree search? c. Given the goal, we need consider only colorings where each sub-square is uniformly 
492. colored. Reformulate the problem and compute the size of the state space. d. How many solutions does this problem have? e. Parts (b) and (c) successively abstracted the original problem (a). Can you give a trans- lation from solutions in problem (c) into solutions in problem (b), and from solutions in problem (b) into solutions for problem (a)? 
493. 3.8 An action such as Go(Sibiu) really consists of a long sequence of finer-grained actions: turn on the car, release the brake, accelerate forward, etc. Having composite actions of this kind reduces the number of steps in a solution sequence, thereby reducing the search time. 
494. AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 116 Chapter 3. Solving Problems by Searching Suppose we take this to the logical extreme, by making super-composite actions out of every possible sequence of Go actions.
495.  Then every problem instance is solved by a single super- composite action, such as Go(Sibiu)Go(Rimnicu Vilcea)Go(Pitesti)Go(Bucharest). Explain how search would work in this formulation. Is this a practical approach for speeding up problem solving? .
496. 3.9 Consider a state space where the start state is number 1 and each state k has two suc- cessors, numbers 2k and 2k + 1. a. Draw the portion of the state space for states 1 to 15. b. Suppose the goal state is 11. List the order in which nodes will be visited for breadth- 
497. first search, depth-limited search with limit 3, and iterative deepening search. c. How well would bidirectional search work on this problem? What is the branching factor in each direction of the bidirectional search? d. Does the answer to (c) suggest a reformulation of the problem that would allow you to 
498. solve the problem of getting from state 1 to a given goal state with almost no search? e. Call the action going from k to 2k Left, and the action going to 2k + 1 Right. Can you find an algorithm to output the solution to this problem without any search at all? 
501. 3.12 Consider the unbounded version of the regular 2D grid shown in Figure 3.9. The start state is at the origin, (0,0), and the goal state is at (x, y). a. What is the branching factor b in this state space? b. How many distinct states are there at depth k (for k > 0)? c. What is the maximum number of nodes expanded by breadth-first search tree search? d. What is the maximum number of nodes expanded by breadth-first search graph search? e.
504.  Two vehicles cannot occupy the same square. .
505. AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
507.  d. Which of the following heuristics are admissible for the problem of moving all n vehi- .
509. a. Suppose that the pieces fit together exactly with no slack. Give a precise formulation of the task as a search problem. b. Identify a suitable uninformed search algorithm for this task and explain your choice. c. Explain briefly why removing any one of the “fork” pieces makes the problem unsolv- 
510. able. d. Give an upper bound on the total size of the state space defined by your formulation. (Hint: think about the maximum branching factor for the construction process and the maximum depth, ignoring the problem of overlapping pieces and loose ends. Begin by pretending that every piece is unique.) 
511. 3.15 Consider the problem of moving k knights from k starting squares s1,...,sk to k goal squares g1,...,gk, on an unbounded chessboard, subject to the rule that no two knights can land on the same square at the same time. Each action consists of moving up to k knights simultaneously. We would like to complete the maneuver in the smallest number of actions. 
512. a. What is the maximum branching factor in this state space, expressed as a function of k? AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE Figure 3.31 The track pieces in a wooden railway set; each is labeled with the number of copies in the set. Note that curved pieces and “fork” pieces (“switches” or “points”) can be flipped over, so they can curve in either direction. Each curve subtends 45 degrees. 
513. x 12 x 16 x 2 x 2 Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 118 Chapter 3. Solving Problems by Searching b. Suppose hi is an admissible heuristic for the problem of moving knight i to goal gi by itself. Which of the following heuristics are admissible for the k-knight problem? Of those, which is the best? (i) min{h1,.
514. ..,hk}. (ii) (iii) DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. .
516.  We want the two friends to meet as quickly as possible. .
517. a. Write a detailed formulation for this search problem. (You will find it helpful to define some formal notation here.) b. Let D(i, j) be the straight-line distance between any two cities i and j. Which, if any, of the following heuristic functions are admissible? (i) D(i, j); (ii) 2 · D(i, j); (iii) D(i, j)/2.
518.  c. Are there completely connected maps for which no solution exists? d. Are there maps in which all solutions require one friend to visit the same city twice? .
519. 3.17 Show that the 8-puzzle states are divided into two disjoint sets, such that any state is reachable from any other state in the same set, while no state is reachable from any state in the other set. (Hint: See Berlekamp et al. (1982).) Devise a procedure that will tell you which set a given state is in, and explain why this is a good thing to have for generating random states. 
521. 3.19 Does a finite state space always lead to a finite search tree? How about a finite state space that is a tree? Can you be more precise about what types of state spaces always lead to finite search trees? (Adapted from Bender, 1996.) 
522. 3.20 Prove that GRAPH-SEARCH satisfies the graph separation property illustrated in Fig- ure 3.9. (Hint: Begin by showing that the property holds at the start, then show that if it holds before an iteration of the algorithm, it holds afterwards.) Describe a search algorithm that violates the property. 
523. 3.21 Give a complete problem formulation for each of the following. Choose a formulation that is precise enough to be implemented. a. You have to color a planar map using only four colors, in such a way that no two 
524. adjacent regions have the same color. AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
525. Section 3.7. Summary 119 b. A 3-foot-tall monkey is in a room where some bananas are suspended from the 8-foot ceiling. He would like to get the bananas. The room contains two stackable, movable, climbable 3-foot-high crates. c. You have a program that outputs the message “illegal input record” when fed a certain file of input records. You know that processing of each record is independent of the other records.
526.  You want to discover what record is illegal. d. You have three jugs, measuring 12 gallons, 8 gallons, and 3 gallons, and a water faucet. You can fill the jugs up or empty them out from one to another or onto the ground. You need to measure out exactly one gallon. .
527. 3.22 The missionaries and cannibals problem is usually stated as follows. Three mission- aries and three cannibals are on one side of a river, along with a boat that can hold one or two people. Find a way to get everyone to the other side, without ever leaving a group of mis- sionaries in one place outnumbered by the cannibals in that place.
528.  This problem is famous in AI because it was the subject of the first paper that approached problem formulation from an analytical viewpoint (Amarel, 1968). .
529. a. Formulate the problem precisely, making only those distinctions necessary to ensure a valid solution. Draw a diagram of the complete state space. b. Implement and solve the problem optimally using an appropriate search algorithm. Is it a good idea to check for repeated states? c. Why do you think people have a hard time solving this puzzle, given that the state space 
530. is so simple? 3.23 Implement two versions of the RESULT(s,a) function for the 8-puzzle: one that copies and edits the data structure for the parent node s and one that modifies the parent state di- rectly (undoing the modifications as needed). Write versions of iterative deepening depth-first search that use these functions and compare their performance. 
531. 3.24 On page 90, we mentioned iterative lengthening search, an iterative analog of uni- form cost search. The idea is to use increasing limits on path cost. If a node is generated whose path cost exceeds the current limit, it is immediately discarded. For each new itera- tion, the limit is set to the lowest path cost of any node discarded in the previous iteration. 
533. many iterations are required in the worst case? d. Implement the algorithm and apply it to instances of the 8-puzzle and traveling sales- person problems. Compare the algorithm’s performance to that of uniform-cost search, and comment on your results. 3.25 Describe a state space in which iterative deepening search performs much worse than depth-first search (for example, O(n2) vs. O(n)). 
534. AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 120 Chapter 3. Solving Problems by Searching DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
535. 3.26 Write a program that will take as input two Web page URLs and find a path of links from one to the other. What is an appropriate search strategy? Is bidirectional search a good idea? Could a search engine be used to implement a predecessor function? 
536. 3.27 Consider the problem of finding the shortest path between two points on a plane that has convex polygonal obstacles as shown in Figure 3.32. This is an idealization of the problem that a robot has to solve to navigate in a crowded environment. 
537. a. Suppose the state space consists of all positions (x, y) in the plane. How many states are there? How many paths are there to the goal? b. Explain briefly why the shortest path from one polygon vertex to any other in the scene must consist of straight-line segments joining some of the vertices of the polygons. Define a good state space now. How large is this state space? c. Define the necessary functions to implement the search problem, including an ACTIONS function that takes a vertex as input and returns a set of vectors, each of which maps the current vertex to one of the vertices that can be reached in a straight line.
538.  (Do not forget the neighbors on the same polygon.) Use the straight-line distance for the heuristic function. d. Apply one or more of the algorithms in this chapter to solve a range of problems in the .
540. 3.29 On page 69, we said that we would not consider problems with negative path costs. In this exercise, we explore this in more depth. AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE Figure 3.32 A scene with polygonal obstacles. S and G are the start and goal states. 
541. S G Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
542. Section 3.7. Summary 121 a. Suppose that actions can have arbitrarily large negative costs; explain why this possi- bility would force any optimal algorithm to explore the entire state space. b. Does it help if we insist that step costs must be greater than or equal to some negative 
543. constant c? Consider both trees and graphs. c. Suppose that there is a set of actions that form a loop in the state space, so that executing the set in some order results in no net change to the state. If all of these actions have negative cost, what does this imply about the optimal behavior for an agent in such an environment? d.
544.  One can easily imagine actions with high negative cost, even in domains such as route finding. For example, some stretches of road might have such beautiful scenery as to far outweigh the normal costs in terms of time and fuel. Explain, in precise terms, within the context of state-space search, why humans do not drive around scenic loops indefinitely, and explain how to define the state space and actions for route finding so that artificial agents can also avoid looping.
545.  e. Can you think of a real domain in which step costs are such as to cause looping? .
546. 3.30 Consider the vacuum-world problem defined in Figure 2.2. a. Which of the algorithms defined in this chapter would be appropriate for this problem? Should the algorithm use tree search or graph search? b. Apply your chosen algorithm to compute an optimal sequence of actions for a 3×3 world whose initial state has dirt in the three top squares and the agent in the center.
547.  c. Construct a search agent for the vacuum world, and evaluate its performance in a set of 3×3 worlds with probability 0.2 of dirt in each square. Include the search cost as well as path cost in the performance measure, using a reasonable exchange rate. d. Compare your best search agent with a simple randomized reflex agent that sucks if .
549.  That is, show the sequence of nodes that the algorithm will consider and the f, g, and h score for each node. .
553. 3.35 We saw on page 94 that the straight-line distance heuristic leads greedy best-first search astray on the problem of going from Iasi to Fagaras. However, the heuristic is per- fect on the opposite problem: going from Fagaras to Iasi. Are there problems for which the heuristic is misleading in both directions? 
555. 3.37 Prove that if a heuristic is consistent, it must be admissible. Construct an admissible heuristic that is not consistent. 3.38 The traveling salesperson problem (TSP) can be solved via the minimum-spanning- tree (MST) heuristic, which is used to estimate the cost of completing a tour, given that a partial tour has already been constructed. The MST cost of a set of cities is the smallest sum of the link costs of any tree that connects all the cities. 
557. graph search to solve instances of the TSP. 3.39 On page 106, we defined the relaxation of the 8-puzzle in which a tile can move from square A to square B if B is blank. The exact solution of this problem defines Gaschnig’s heuristic (Gaschnig, 1979).
558.  Explain why Gaschnig’s heuristic is at least as accurate as h1 (misplaced tiles), and show cases where it is more accurate than both h1 and h2 (Manhattan distance). Can you suggest a way to calculate Gaschnig’s heuristic efficiently? .
559. 3.40 We gave two simple heuristics for the 8-puzzle: Manhattan distance and misplaced tiles. Several heuristics in the literature purport to improve on this—see, for example, Nils- son (1971), Mostow and Prieditis (1989), and Hansson et al. (1992). Test these claims by implementing the heuristics and comparing the performance of the resulting algorithms. 
