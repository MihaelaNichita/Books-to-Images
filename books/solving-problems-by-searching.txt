Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
In which we see how an agent can find a sequence of actions that achieves its goals, when no single action will do. 
The simplest agents discussed in Chapter 2 were the reflex agents, which base their actions on a direct mapping from states to actions. Such agents cannot operate well in environments for which this mapping would be too large to store and would take too long to learn. Goal-based agents, on the other hand, can succeed by considering future actions and the desirability of their outcomes. This chapter describes one kind of goal-based agent called a problem-solving agent. PROBLEM-SOLVING AGENT Problem-solving agents think about the world using atomic representations, as described in Section 2.4.7—that is, states of the world are considered as wholes, with no internal structure visible to the problem-solving algorithms. Goal-based agents that use more advanced fac- tored or structured representations are usually called planning agents and are discussed in Chapter 7 and 11. 
We start our discussion of problem solving by defining precisely the elements that con- stitute a “problem” and its “solution,” and give several examples to illustrate these definitions. We then describe several general-purpose search algorithms that can be used to solve these problems. We will see several uninformed search algorithms—algorithms that are given no information about the problem other than its definition. Although some of these algorithms can solve any solvable problem, none of them can do so efficiently. Informed search al- gorithms, on the other hand, can often do quite well given some idea of where to look for solutions. 
In this chapter, we limit ourselves to the simplest kind of task environment, for which the solution to a problem is always a fixed sequence of actions. The more general case—where the agent’s future actions may vary depending on future percepts—is handled in Chapter 4. 
This chapter uses concepts from the analysis of algorithms. Readers unfamiliar with the concepts of asymptotic complexity (that is, O() notation) and NP-completeness should consult Appendix A. 
65 
3 SOLVING PROBLEMS BY 
SEARCHING 
Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
66 Chapter 3. Solving Problems by Searching 
3.1 PROBLEM-SOLVING AGENTS 
Intelligent agents are supposed to maximize their performance measure. As we mentioned in Chapter 2, achieving this is sometimes simplified if the agent can adopt a goal and aim at satisfying it. Let us first look at why and how an agent might do this. 
Imagine an agent in the city of Arad, Romania, enjoying a touring holiday. The agent’s performance measure contains many factors: it wants to improve its suntan, improve its Ro- manian, take in the sights, enjoy the nightlife (such as it is), avoid hangovers, and so on. The decision problem is a complex one involving many tradeoffs and careful reading of guide- books. Now, suppose the agent has a nonrefundable ticket to fly out of Bucharest the follow- ing day. In that case, it makes sense for the agent to adopt the goal of getting to Bucharest. Courses of action that don’t reach Bucharest on time can be rejected without further consid- eration and the agent’s decision problem is greatly simplified. Goals help organize behavior by limiting the objectives that the agent is trying to achieve and hence the actions it needs 
GOAL FORMULATION 
to consider. Goal formulation, based on the current situation and the agent’s performance measure, is the first step in problem solving. We will consider a goal to be a set of world states—exactly those states in which the goal is satisfied. The agent’s task is to find out how to act, now and in the future, so that it reaches a goal state. Before it can do this, it needs to decide (or we need to decide on its behalf) what sorts of actions and states it should consider. If it were to consider actions at the level of “move the left foot forward an inch” or “turn the steering wheel one degree left,” the agent would probably never find its way out of the parking lot, let alone to Bucharest, because at that level of detail there is too much uncertainty in the world and there would be PROBLEM FORMULATION too many steps in a solution. Problem formulation is the process of deciding what actions and states to consider, given a goal. We will discuss this process in more detail later. For now, let us assume that the agent will consider actions at the level of driving from one major town to another. Each state therefore corresponds to being in a particular town. 
Our agent has now adopted the goal of driving to Bucharest, and is considering where to go from Arad. There are three roads out of Arad, one toward Sibiu, one to Timisoara, and one to Zerind. None of these achieves the goal, so unless the agent is very familiar with the geography of Romania, it will not know which road to follow.1 In other words, the agent will not know which of its possible actions is best, because it does not yet know enough about the state that results from taking each action. If the agent has no additional information—i.e., if the environment is unknown in the sense defined in Section 2.3—then it is has no choice but to try one of the actions at random. This sad situation is discussed in Chapter 4. 
But suppose the agent has a map of Romania. The point of a map is to provide the agent with information about the states it might get itself into, and the actions it can take. The agent can use this information to consider subsequent stages of a hypothetical journey via each of the three towns, trying to find a journey that eventually gets to Bucharest. Once it has 
DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
1 We are assuming that most readers are in the same position and can easily imagine themselves to be as clueless as our agent. We apologize to Romanian readers who are unable to take advantage of this pedagogical device. 
AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE 
Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
Section 3.1. Problem-Solving Agents 67 
found a path on the map from Arad to Bucharest, it can achieve its goal by carrying out the driving actions that correspond to the legs of the journey. In general, an agent with several immediate options of unknown value can decide what to do by first examining future actions that eventually lead to states of known value. 
To be more specific about what we mean by “examining future actions,” we have to be more specific about properties of the environment, as defined in Section 2.3. For now, we will assume that the environment is observable, so that the agent always knows the current state. For the agent driving in Romania, it’s reasonable to suppose that each city on the map has a sign indicating its presence to arriving drivers. We will also assume the environment is discrete, so that at any given state there are only finitely many actions to choose from. This is true for navigating in Romania because each city is connected to a small number of other cities. We will assume the environment is known, so that the agent knows which states are reached by each action. (Having an accurate map suffices to meet this condition for navigation problems.) Finally, we assume that the environment is deterministic, so that each action has exactly one outcome. Under ideal conditions, this is true for the agent in Romania—it means that if it chooses to drive from Arad to Sibiu, it does end up in Sibiu. Of course, conditions are not always ideal, as we will see in Chapter 4. 
Under these assumptions, the solution to any problem is a fixed sequence of actions. “Of course!” one might say, “What else could it be?” Well, in general it could be a branching strategy that recommends different actions in the future depending on what percepts arrive. For example, under less than ideal conditions, the agent might plan to drive from Arad to Sibiu and then to Rimnicu Vilcea, but may also need to have a contingency plan in case it arrives by accident in Zerind instead of Sibiu. Fortunately, if the agent knows the initial state and the environment is known and deterministic, it knows exactly where it will be after the first action and what it will perceive. Since there is only one possible percept after the first action, the solution can specify only one possible second action, and so on. The process of looking for a sequence of actions that reaches the goal is called search. SEARCH A search algorithm takes a problem as input and returns a solution in the form of an action SOLUTION sequence. Once a solution is found, the actions it recommends can be carried out. This is called the execution phase. Thus, we have a simple “formulate, search, execute” design EXECUTION for the agent, as shown in Figure 3.1. After formulating a goal and a problem to solve, the agent calls a search procedure to solve it. It then uses the solution to guide its actions, doing whatever the solution recommends as the next thing to do—typically, the first action of the sequence—and then removing that step from the sequence. Once the solution has been executed, the agent will formulate a new goal. 
Notice that while the agent is executing the solution sequence it ignores its percepts when choosing an action because it knows in advance what they will be. An agent that carries out its plans with its eyes closed, so to speak, must be quite certain of what is going on. Control theorists call this an open-loop system, because ignoring the percepts breaks the OPEN-LOOP 
loop between agent and environment. 
We first describe the process of problem formulation, and then devote the bulk of the chapter to various algorithms for the SEARCH function. We will not discuss the workings of the UPDATE-STATE and FORMULATE-GOAL functions further in this chapter. 
AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE 
Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
68 Chapter 3. Solving Problems by Searching 
3.1.1 Well-defined problems and solutions 
PROBLEM A problem can be defined formally by five components: INITIAL STATE 
• The initial state that the agent starts in. For example, the initial state for our agent in Romania might be described as In(Arad). 
ACTIONS 
• A description of the possible actions available to the agent. Given a particular state s, ACTIONS(s) returns the set of actions that can be executed in s. For example, from the state In(Arad), the possible actions are {Go(Sibiu),Go(Timisoara),Go(Zerind)}. 
• A description of what each action does; the formal name for this is the transition 
TRANSITION MODEL model, specified by a function RESULT(s,a) that returns the state that results from SUCCESSOR doing action a in state s. We will also use the term successor to refer to any state reachable from a given state by a single action.2 For example, we have 
RESULT(In(Arad),Go(Zerind)) = In(Zerind) . 
STATE SPACE 
Together, the initial state, actions, and transition model implicitly define the state space of the problem—the set of all states reachable from the initial state by any sequence 
GRAPH 
of actions. The state space forms a directed network or graph in which the nodes are states and the links between nodes are actions. (The map of Romania shown in Figure 3.2 can be interpreted as a state-space graph if we view each road as standing 
PATH 
for two driving actions, one in each direction.) A path in the state space is a sequence of states connected by a sequence of actions. 
DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
2 Many treatments of problem solving, including previous editions of this book, talk about the successor func- tion, which returns the set of all successors, instead of actions and results. Although convenient in some ways, this formulation makes it difficult to describe an agent that knows what actions it can try but not what they achieve. 
AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE 
function SIMPLE-PROBLEM-SOLVING-AGENT(percept) returns an action 
persistent: seq, an action sequence, initially empty 
state, some description of the current world state goal, a goal, initially null problem, a problem formulation 
state ←UPDATE-STATE(state,percept) if seq is empty then do 
goal ← FORMULATE-GOAL(state) problem ←FORMULATE-PROBLEM(state,goal) seq ←SEARCH(problem) if seq = failure then return a null action action ← FIRST(seq) seq ← REST(seq) return action 
Figure 3.1 A simple problem-solving agent. It first formulates a goal and a problem, searches for a sequence of actions that would solve the problem, and then executes the actions one at a time. When this is complete, it formulates another goal and starts over. 
Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
Section 3.1. Problem-Solving Agents 69 
• The goal test, which determines whether a given state is a goal state. Sometimes there GOAL TEST is an explicit set of possible goal states, and the test simply checks whether the given state is one of them. The agent’s goal in Romania is the singleton set {In(Bucharest)}. Sometimes the goal is specified by an abstract property rather than an explicitly enumer- ated set of states. For example, in chess, the goal is to reach a state called “checkmate,” where the opponent’s king is under attack and can’t escape. 
• A path cost function that assigns a numeric cost to each path. The problem-solving PATH COST agent chooses a cost function that reflects its own performance measure. For the agent trying to get to Bucharest, time is of the essence, so the cost of a path might be its length in kilometers. In this chapter, we assume that the cost of a path can be described as the sum of the costs of the individual actions along the path.3 The step cost of taking action STEP COST a in state s to reach state s′ is denoted by c(s, a, s′). The step costs for Romania are shown in Figure 3.2 as route distances. We will assume that step costs are nonnegative.4 
The preceding elements define a problem and can be gathered together into a single data structure that is given as input to a problem-solving algorithm. A solution to a problem is an action sequence that leads from the initial state to a goal state. Solution quality is measured by the path cost function, and an optimal solution has the lowest path cost among all solutions. OPTIMAL SOLUTION 
3 This assumption is algorithmically convenient, but also has a more fundamental justification—see page 629 in Chapter 17. 4 The implications of negative costs are explored in Exercise 3.29. 
AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE 
Oradea 71 
75 
Zerind 
151 
Arad 
140 
Sibiu 99 
Fagaras 118 
80 
Timisoara 
111 
Lugoj 
97 
Pitesti 
70Mehadia 
101 
75 
Drobeta 
120 
Craiova 
Figure 3.2 A simplified road map of part of Romania. 
Iasi 
Rimnicu Vilcea 
211 
146 85 
138 
Bucharest 
90 
Giurgiu 
Neamt 
87 
92 
Vaslui 
14298 
Hirsova Urziceni 
86 
Eforie 
Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
70 Chapter 3. Solving Problems by Searching 
3.1.2 Formulating problems 
In the preceding section we proposed a formulation of the problem of getting to Bucharest in terms of the initial state, actions, transition model, goal test, and path cost. This formulation seems reasonable, but it is still a model—an abstract mathematical description—and not the real thing. Compare the simple state description we have chosen, In(Arad), to an actual cross- country trip, where the state of the world includes so many things: the traveling companions, what is on the radio, the scenery out of the window, whether there are any law enforcement officers nearby, how far it is to the next rest stop, the condition of the road, the weather, and so on. All these considerations are left out of our state descriptions because they are irrelevant to the problem of finding a route to Bucharest. The process of removing detail 
ABSTRACTION 
from a representation is called abstraction. In addition to abstracting the state description, we must abstract the actions themselves. A driving action has many effects. Besides changing the location of the vehicle and its oc- cupants, it takes up time, consumes fuel, generates pollution, and changes the agent (as they say, travel is broadening). Our formulation takes into account only the change in location. Also, there are many actions that we will omit altogether: turning on the radio, looking out of the window, slowing down for law enforcement officers, and so on. And of course, we don’t specify actions at the level of “turn steering wheel to the left by three degrees.” 
Can we be more precise about defining the appropriate level of abstraction? Think of the abstract states and actions we have chosen as corresponding to large sets of detailed world states and detailed action sequences. Now consider a solution to the abstract problem: for example, the path from Arad to Sibiu to Rimnicu Vilcea to Pitesti to Bucharest. This abstract solution corresponds to a large number of more detailed paths. For example, we could drive with the radio on between Sibiu and Rimnicu Vilcea, and then switch it off for the rest of the trip. The abstraction is valid if we can expand any abstract solution into a solution in the more detailed world; a sufficient condition is that for every detailed state that is “in Arad,” there is a detailed path to some state that is “in Sibiu,” and so on.5 The abstraction is useful if carrying out each of the actions in the solution is easier than the original problem; in this case they are easy enough that they can be carried out without further search or planning by an average driving agent. The choice of a good abstraction thus involves removing as much detail as possible while retaining validity and ensuring that the abstract actions are easy to carry out. Were it not for the ability to construct useful abstractions, intelligent agents would be completely swamped by the real world. 
3.2 EXAMPLE PROBLEMS 
The problem-solving approach has been applied to a vast array of task environments. We list some of the best known here, distinguishing between toy and real-world problems. A 
TOY PROBLEM toy problem is intended to illustrate or exercise various problem-solving methods. It can be DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
5 See Section 12.2 for a more complete set of definitions and algorithms. 
AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE 
Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
Section 3.2. Example Problems 71 
given a concise, exact description and hence is usable by different researchers to compare the performance of algorithms. A real-world problem is one whose solutions people actually REAL-WORLD PROBLEM care about. They tend not to have a single agreed-upon description, but we will attempt to 
give the general flavor of their formulations. 
3.2.1 Toy problems 
The first example we will examine is the vacuum world first introduced in Chapter 2. (See Figure 2.2.) This can be formulated as a problem as follows: 
• States: The state is determined by both the agent location and the dirt locations. The agent is in one of two locations, each of which might or might not contain dirt. Thus there are 2 × 22 = 8 possible world states. A larger environment with n locations has n · 2n states. 
• Initial state: Any state can be designated as the initial state. 
• Actions: In this simple environment, each state has just three actions: Left, Right, and Suck. Larger environments might also include Up and Down. 
• Transition model: The actions have their expected effects, except that moving Left in the leftmost square, moving Right in the rightmost square, and Sucking in a clean square have no effect. The complete state space is shown in Figure 3.3. 
• Goal test: This checks whether all the squares are clean. 
• Path cost: Each step costs 1, so the path cost is the number of steps in the path. 
Compared with the real world, this toy problem has discrete locations, discrete dirt, reliable cleaning, and it never gets messed up once cleaned. In Chapter 4, we will relax some of these assumptions. The 8-puzzle, an instance of which is shown in Figure 3.4, consists of a 3×3 board with 8-PUZZLE eight numbered tiles and a blank space. A tile adjacent to the blank space can slide into the space. The object is to reach a specified goal state, such as the one shown on the right of the figure. The standard formulation is as follows: 
• States: A state description specifies the location of each of the eight tiles and the blank in one of the nine squares. 
• Initial state: Any state can be designated as the initial state. Note that any given goal can be reached from exactly half of the possible initial states (Exercise 3.17). 
• Actions: The simplest formulation defines the actions as movements of the blank space Left, Right, Up, or Down. Different subsets of these are possible depending on where the blank is. 
• Transition model: Given a state and action, this returns the resulting state; for example, if we apply Left to the start state in Figure 3.4, the resulting state has the 5 and the blank switched. 
• Goal test: This checks whether the state matches the goal configuration shown in Fig- ure 3.4. (Other goal configurations are possible.) 
• Path cost: Each step costs 1, so the path cost is the number of steps in the path. 
AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE 
Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
72 Chapter 3. Solving Problems by Searching 
What abstractions have we included here? The actions are abstracted to their beginning and final states, ignoring the intermediate locations where the block is sliding. We have abstracted away actions such as shaking the board when pieces get stuck, or extracting the pieces with a knife and putting them back again. We are left with a description of the rules of the puzzle, avoiding all the details of physical manipulations. SLIDING-BLOCK PUZZLES The 8-puzzle belongs to the family of sliding-block puzzles, which are often used as test problems for new search algorithms in AI. This family is known to be NP-complete, so one does not expect to find methods significantly better in the worst case than the search algorithms described in this chapter and the next. The 8-puzzle has 9!/2 = 181,440 reachable states and is easily solved. The 15-puzzle (on a 4×4 board) has around 1.3 trillion states, and random instances can be solved optimally in a few milliseconds by the best search algorithms. 
DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE 
L L R 
RR R 
Figure 3.3 The state space for the vacuum world. Links denote actions: L = Left,R= Right,S= Suck. 
Figure 3.4 A typical instance of the 8-puzzle. 
S 
S S 
RL 
785 
8 
LL 
23 
46 
1 
2 
3 4 
6 7 
Start State Goal State 
5 
1 
RL 
S S 
S S 
RL 
RL 
S 
Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
Section 3.2. Example Problems 73 
The 24-puzzle (on a 5 × 5 board) has around 1025 states, and random instances take several hours to solve optimally. The goal of the 8-queens problem is to place eight queens on a chessboard such that 8-QUEENS PROBLEM no queen attacks any other. (A queen attacks any piece in the same row, column or diago- nal.) Figure 3.5 shows an attempted solution that fails: the queen in the rightmost column is attacked by the queen at the top left. 
Although efficient special-purpose algorithms exist for this problem and for the whole n-queens family, it remains a useful test problem for search algorithms. There are two main kinds of formulation. An incremental formulation involves operators that augment the state INCREMENTAL FORMULATION description, starting with an empty state; for the 8-queens problem, this means that each action adds a queen to the state. A complete-state formulation starts with all 8 queens on COMPLETE-STATE FORMULATION the board and moves them around. In either case, the path cost is of no interest because only 
the final state counts. The first incremental formulation one might try is the following: 
• States: Any arrangement of 0 to 8 queens on the board is a state. 
• Initial state: No queens on the board. 
• Actions: Add a queen to any empty square. 
• Transition model: Returns the board with the a queen added to the specified square. 
• Goal test: 8 queens are on the board, none attacked. 
In this formulation, we have 64 · 63···57 ≈ 1.8×1014 possible sequences to investigate. A better formulation would prohibit placing a queen in any square that is already attacked: 
• States: All possible arrangements of n queens (0 ≤ n ≤ 8), one per column in the leftmost n columns, with no queen attacking another. 
AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE 
Figure 3.5 Almost a solution to the 8-queens problem. (Solution is left as an exercise.) 
Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
74 Chapter 3. Solving Problems by Searching 
• Actions: Add a queen to any square in the leftmost empty column such that it is not attacked by any other queen. This formulation reduces the 8-queens state space from 1.8×1014 to just 2,057, and solutions are easy to find. On the other hand, for 100 queens the reduction is from roughly 10400 states to about 1052 states (Exercise 3.18)—a big improvement, but not enough to make the problem tractable. Section 4.1 describes the complete-state formulation and Chapter 6 gives a simple algorithm that solves even the million-queens problem with ease. 
Our final toy problem was devised by Donald Knuth (1964) and illustrates how infinite state spaces can arise. Knuth conjectured that one can start with the number 4, apply a sequence of factorial, square root, and floor operations, and arrive at any desired positive integer. ⌊√√√√√ 
For example, 
(4!)!⌋ = 5 . 
The problem definition is very simple: 
• States: Positive numbers. 
• Initial state: 4. 
• Actions: Apply factorial, square root, or floor operation. Factorial can be applied only to integers. 
• Transition model: As given by the mathematical definitions of the operations. 
• Goal test: State is the desired positive integer. 
To our knowledge there is no bound on how large a number might be constructed in the pro- cess of reaching a given target—for example, the number 620,448,401,733,239,439,360,000 is generated in the expression for 5—so the state space for this problem is infinite. Such state spaces arise very frequently in tasks involving the generation of mathematical expressions, circuits, proofs, programs, and other recursively defined objects. 
3.2.2 Real-world problems 
ROUTE-FINDING PROBLEM We have already seen how the route-finding problem is defined in terms of specified loca- tions and transitions along links between them. Route-finding algorithms are used in a variety of applications. Some, such as Web sites and in-car systems that provide driving directions, are relatively straightforward extensions of the Romania example. Others, such as routing video streams in computer networks, military operations planning, and airline travel planning systems, involve much more complex specifications. Consider the airline travel problems that must be solved by a travel planning Web site: 
• States: Each state obviously includes a location (e.g., an airport) and the current time. Furthermore, because the cost of an action (a flight segment) may depend on previous segments, their fare bases, and whether they were domestic or international, the state must record extra information about these “historical” aspects. 
• Initial state: This is specified by the user’s query. 
AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE 
DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
√√√√ 
√ 
√ 
√ 
Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
Section 3.2. Example Problems 75 
• Actions: Take any flight from the current location, in any seat class, leaving after the current time, leaving enough time for within-airport transfer if there is a preceding flight segment. 
• Transition model: The state resulting from taking a flight will have the flight’s desti- nation as the current location and the flight’s arrival time as the current time. 
• Goal test: Are we at the final destination specified by the user? 
• Path cost: This depends on monetary cost, waiting time, flight time, customs and im- migration procedures, seat quality, time of day, type of airplane, frequent-flyer mileage awards, and so on. 
Commercial travel advice systems use a problem formulation of this kind, with many addi- tional complications to handle the byzantine fare structures that airlines impose. Any sea- soned traveler knows, however, that not all air travel goes according to plan. A really good system should include contingency plans—such as backup reservations on alternate flights— to the extent that these are justified by the cost and likelihood of failure of the original plan. Touring problems are closely related to route-finding problems, but with an impor- TOURING PROBLEMS tant difference. Consider, for example, the problem “Visit every city in Figure 3.2 at least once, starting and ending in Bucharest.” As with route finding, the actions correspond to trips between adjacent cities. The state space, however, is quite different. Each state must include not just the current location but also the set of cities the agent has visited. So the initial state would be In(Bucharest),Visited({Bucharest}), a typical intermedi- ate state would be In(Vaslui),Visited({Bucharest,Urziceni,Vaslui}), and the goal test would check whether the agent is in Bucharest and all 20 cities have been visited. The traveling salesperson problem (TSP) is a touring problem in which each city TRAVELING SALESPERSON PROBLEM must be visited exactly once. The aim is to find the shortest tour. The problem is known to be NP-hard, but an enormous amount of effort has been expended to improve the capabilities of TSP algorithms. In addition to planning trips for traveling salespersons, these algorithms have been used for tasks such as planning movements of automatic circuit-board drills and of stocking machines on shop floors. A VLSI layout problem requires positioning millions of components and connections VLSI LAYOUT on a chip to minimize area, minimize circuit delays, minimize stray capacitances, and max- imize manufacturing yield. The layout problem comes after the logical design phase, and is usually split into two parts: cell layout and channel routing. In cell layout, the primitive components of the circuit are grouped into cells, each of which performs some recognized function. Each cell has a fixed footprint (size and shape) and requires a certain number of connections to each of the other cells. The aim is to place the cells on the chip so that they do not overlap and so that there is room for the connecting wires to be placed between the cells. Channel routing finds a specific route for each wire through the gaps between the cells. These search problems are extremely complex, but definitely worth solving. Later in this chapter, we will see some algorithms capable of solving them. Robot navigation is a generalization of the route-finding problem described earlier. ROBOT NAVIGATION Rather than a discrete set of routes, a robot can move in a continuous space with (in principle) an infinite set of possible actions and states. For a circular robot moving on a flat surface, 
AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE 
Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
76 Chapter 3. Solving Problems by Searching 
the space is essentially two-dimensional. When the robot has arms and legs or wheels that must also be controlled, the search space becomes many-dimensional. Advanced techniques are required just to make the search space finite. We examine some of these methods in Chapter 25. In addition to the complexity of the problem, real robots must also deal with errors in their sensor readings and motor controls. AUTOMATIC ASSEMBLY SEQUENCING Automatic assembly sequencing of complex objects by a robot was first demonstrated by FREDDY (Michie, 1972). Progress since then has been slow but sure, to the point where the assembly of intricate objects such as electric motors is economically feasible. In assembly problems, the aim is to find an order in which to assemble the parts of some object. If the wrong order is chosen, there will be no way to add some part later in the sequence without undoing some of the work already done. Checking a step in the sequence for feasibility is a difficult geometrical search problem closely related to robot navigation. Thus, the generation of legal actions is the expensive part of assembly sequencing. Any practical algorithm must avoid exploring all but a tiny fraction of the state space. Another important assembly problem 
PROTEIN DESIGN 
is protein design, in which the goal is to find a sequence of amino acids that will fold into a three-dimensional protein with the right properties to cure some disease. 
3.3 SEARCHING FOR SOLUTIONS 
Having formulated some problems, we now need to solve them. A solution is an action sequence, so search algorithms work by considering various possible action sequences. The 
SEARCH TREE possible action sequences starting at the initial state form a search tree with the initial state NODE at the root; the branches are actions and the nodes correspond to states in the state space of the problem. Figure 3.6 shows the first few steps in growing the search tree for finding a route from Arad to Bucharest. The root node of the tree corresponds to the initial state, In(Arad). The first step is to test whether this is a goal state. (Clearly it is not, but it is important to check so that we can solve trick problems like “starting in Arad, get to Arad.”) Then we 
EXPANDING need to consider taking various actions. This is done by expanding the current state; that GENERATING is, applying each legal action to the current state, thereby generating a new set of states. In PARENT NODE this case, we add three branches from the parent node In(Arad) leading to three new child CHILD NODE nodes: In(Sibiu), In(Timisoara), and In(Zerind). Now we must choose which of these three possibilities to consider further. This is the essence of search—following up one option now and putting the others aside for later, in case the first choice does not lead to a solution. Suppose we choose Sibiu first. We check to see whether it is a goal state (it is not) and then expand it to get In(Arad), In(Fagaras), In(Oradea), and In(RimnicuVilcea). We can then choose any of these four, or go 
LEAF NODE 
back and choose Timisoara or Zerind. Each of these six nodes is a leaf node, that is, a node with no children in the tree. The set of all leaf nodes available for expansion at any given 
FRONTIER point is called the frontier. (Many authors call it the open list, which is both geographically OPEN LIST less evocative and inaccurate, as it need not be stored as a list at all.) In Figure 3.6, the frontier 
of each tree consists of those nodes with bold outlines. 
AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE 
DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
Section 3.3. Searching for Solutions 77 
The process of choosing and expanding nodes in the frontier continues until either a solution is found or there are no more states to be expanded. The general TREE-SEARCH algorithm is shown informally in Figure 3.7. Search algorithms all share this basic structure; they vary primarily according to how they choose which state to expand next—the so-called search strategy. SEARCH STRATEGY 
The eagle-eyed reader will notice one peculiar thing about the search tree shown in Fig- ure 3.6: it includes the path from Arad to Sibiu and back to Arad again! We say that In(Arad) is a repeated state in the search tree, generated in this case by a loopy path. Considering REPEATED STATE LOOPY PATH such loopy paths means that the complete search tree for Romania is infinite, because there is no limit to how often one can traverse a loop. On the other hand, the state space—the map shown in Figure 3.2—has only 20 states. As we will see in Section 3.4, loops can cause certain algorithms to fail, making otherwise solvable problems unsolvable. Fortunately, there is no need to consider loopy paths. We can rely on more than intuition for this: because path costs are additive and step costs are nonnegative, a loopy path to any given state is never better than the same path with the loop removed. Loopy paths are a special case of the more general concept of redundant paths, which REDUNDANT PATH 
Figure 3.6 Partial search trees for finding a route from Arad to Bucharest. Nodes that have been expanded are shaded; nodes that have been generated but not yet expanded are outlined in bold; nodes that have not yet been generated are shown in faint dashed lines. 
(a) The initial state 
(b) After expanding Arad 
(c) After expanding Sibiu 
AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE 
Arad 
Sibiu Zerind Arad Fagaras Oradea 
Rimnicu Vilcea 
Timisoara 
Rimnicu Vilcea Arad Lugoj 
Arad Oradea 
Arad 
Sibiu Timisoara 
Zerind 
Arad Fagaras Oradea Rimnicu Vilcea Arad Lugoj Arad Oradea 
Arad 
Sibiu 
Timisoara 
Zerind 
Arad Fagaras Oradea 
Arad Lugoj Arad Oradea 
Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
78 Chapter 3. Solving Problems by Searching 
exist whenever there is more than one way to get from one state to another. Consider the paths Arad–Sibiu (140km long) and Arad–Zerind–Oradea–Sibiu (297km long). Obviously, the second path is redundant—it’s just a worse way to get to the same state. If you are concerned about reaching the goal, there’s never any reason to keep around more than one path to any given state, because any goal state that is reachable by extending one path is also reachable by extending the other. 
In some cases, it is possible to define the problem itself so as to eliminate redundant paths. For example, if we formulate the 8-queens problem (page 73) so that a queen can be placed in any column, then each state with n queens can be reached by n! different paths; but if we reformulate the problem so that each new queen is placed in the leftmost empty column, then each state can be reached only through one path. 
In other cases, redundant paths are unavoidable. This includes all problems where the actions are reversible, such as route-finding problems and sliding-block puzzles. Route- 
RECTANGULAR GRID 
finding on a rectangular grid, as illustrated in Figure 3.9, is a particularly important example in computer games. In such a grid, each state has four successors, so a search tree of depth d that includes repeated states has 4d leaves; but there are only about 2d2 distinct states within d steps of any given state. For d = 20, this means about a trillion nodes but only about 800 distinct states. Thus, following redundant paths can cause a tractable problem to become intractable. This is true even for algorithms that know how to avoid infinite loops. 
As the saying goes, algorithms that forget their history are doomed to repeat it. The 
AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE 
DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
function TREE-SEARCH(problem) returns a solution, or failure 
initialize the frontier using the initial state of problem loop do 
if the frontier is empty then return failure choose a leaf node and remove it from the frontier if the node contains a goal state then return the corresponding solution expand the chosen node, adding the resulting nodes to the frontier 
function GRAPH-SEARCH(problem) returns a solution, or failure 
initialize the frontier using the initial state of problem initialize the explored set to be empty loop do 
if the frontier is empty then return failure choose a leaf node and remove it from the frontier if the node contains a goal state then return the corresponding solution add the node to the explored set expand the chosen node, adding the resulting nodes to the frontier 
only if not in the frontier or explored set 
Figure 3.7 An informal description of the general tree-search and graph-search algo- rithms. The parts of GRAPH-SEARCH marked in bold italic are the additions needed to handle repeated states. 
Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
Section 3.3. Searching for Solutions 79 
way to avoid exploring redundant paths is to remember where one has been. To do this, we augment the TREE-SEARCH algorithm with a data structure called the explored set, which EXPLORED SET remembers every expanded node. (Many authors call this the closed list—see earlier com- CLOSED LIST ment on open lists.) Newly generated nodes that match previously generated nodes—ones in the explored set or the frontier—can be discarded instead of being added to the frontier. The new algorithm, called GRAPH-SEARCH, is shown informally in Figure 3.7. The spe- cific algorithms in this chapter are, for the most part, special cases or variants of this general design.Clearly, the search tree constructed by the GRAPH-SEARCH algorithm contains at most one copy of any given state, so we can think of it as growing a tree directly on the state- space graph itself, as shown in Figure 3.8. The algorithm has another nice property: the frontier separates the state-space graph into the explored region and the unexplored region, SEPARATOR so that every path from the initial state to an unexplored state has to pass through a state in the frontier. (If this seems completely obvious, try Exercise 3.20 now.) This property is illustrated in Figure 3.9. As every step moves a state from the frontier into the explored region, while moving some states from the unexplored region into the frontier, we see that the algorithm is systematically examining the states in the state space, one by one, until it finds a solution. 
3.3.1 Infrastructure for search algorithms 
Search algorithms require a data structure to keep track of the search tree that is being con- structed. For each node n of the tree, we will have a structure that contains the following four components: 
• n.STATE: the state in the state space to which the node corresponds; 
• n.PARENT: the node in the search tree that generated this node; 
• n.ACTION: the action that was applied to the parent to generate the node; 
• n.PATH-COST: the cost, traditionally denoted by g(n), of the path from the initial state to the node, as indicated by the parent pointers. Given the components for a parent node, it is easy to see how to compute the necessary components for a child node. The function CHILD-NODE takes a parent node and an action and returns the resulting child node: 
AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE 
Figure 3.8 A sequence of search trees generated by a graph search on the Romania prob- lem of Figure 3.2. At each stage, we have extended each path by one step. Notice that at the third stage, the northernmost city (Oradea) has become a dead end: both of its successors are already explored via other paths. 
Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
80 Chapter 3. Solving Problems by Searching 
The node data structure is depicted in Figure 3.10. Notice how the PARENT pointers string the nodes together into a tree structure. These pointers also allow the solution path to be extracted when a goal node is found; we’ll use the SOLUTION function to return the sequence of actions obtained by following parent pointers back to the root. 
Up to now, we have not been very careful to distinguish between nodes and states, but in writing detailed algorithms it’s important to do so. A node is a bookkeeping data structure used to represent the search tree. A state corresponds to a configuration of the world. Thus, nodes are on particular paths, as defined by PARENT pointers, whereas states are not. Furthermore, two different nodes can contain the same world state, if that state is generated via two different search paths. 
Now that we have nodes, we need somewhere to put them. The frontier needs to be stored in such a way that the search algorithm can easily choose the next node to expand 
QUEUE 
according to its preferred strategy. The appropriate data structure for this is a queue. The operations on a queue are as follows: 
• EMPTY?(queue) returns true only if there are no more elements in the queue. 
• POP(queue) removes the first element of the queue and returns it. 
• INSERT(element, queue) inserts an element and returns the resulting queue. 
AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE 
DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
function CHILD-NODE(problem,parent,action) returns a node 
return a node with 
STATE = problem.RESULT(parent.STATE,action), PARENT = parent, ACTION = action, PATH-COST = parent.PATH-COST + problem.STEP-COST(parent.STATE,action) 
Figure 3.9 The separation property of GRAPH-SEARCH, illustrated on a rectangular-grid problem. The frontier (white nodes) always separates the explored region of the state space (black nodes) from the unexplored region (gray nodes). In (a), just the root has been ex- panded. In (b), one leaf node has been expanded. In (c), the remaining successors of the root have been expanded in clockwise order. 
(c) (b) (a) 
Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
Section 3.3. Searching for Solutions 81 
Queues are characterized by the order in which they store the inserted nodes. Three common variants are the first-in, first-out or FIFO queue, which pops the oldest element of the queue; FIFO QUEUE the last-in, first-out or LIFO queue (also known as a stack), which pops the newest element LIFO QUEUE of the queue; and the priority queue, which pops the element of the queue with the highest PRIORITY QUEUE 
priority according to some ordering function. 
The explored set can be implemented with a hash table to allow efficient checking for repeated states. With a good implementation, insertion and lookup can be done in roughly constant time, independent of the number of states stored. One must take care to implement the hash table with the right notion of equality between states. For example, in the traveling salesperson problem (page 75), the hash table needs to know that the set of visited cities {Bucharest,Urziceni,Vaslui} is the same as {Urziceni,Vaslui,Bucharest}. Sometimes this can be achieved most easily by insisting that the data structures for states be in some canonical form; that is, logically equivalent states should map to the same data structure. In the case CANONICAL FORM of states described by sets, for example, a bit-vector representation or a sorted list without repetition would be canonical, whereas an unsorted list would not. 
3.3.2 Measuring problem-solving performance 
Before we get into the design of specific search algorithms, we need to consider the criteria that might be used to choose among them. We will evaluate an algorithm’s performance in four ways: 
• Completeness: Is the algorithm guaranteed to find a solution when there is one? COMPLETENESS 
• Optimality: Does the strategy find the optimal solution, as defined on page 69? OPTIMALITY 
• Time complexity: How long does it take to find a solution? TIME COMPLEXITY 
• Space complexity: How much memory is needed to perform the search? SPACE COMPLEXITY 
Time and space complexity are always considered with respect to some measure of the prob- lem difficulty. In theoretical computer science, the typical measure is the size of the state space graph, |V | + |E|. where V is the set of vertices (nodes) of the graph and E is the set 
AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE 
Figure 3.10 Nodes are the data structures from which the search tree is constructed. Each has a parent, a state, and various bookkeeping fields. Arrows point from child to parent. 
8 4561 
7 234561 8 
7 
23
Node 
STATE 
PARENT 
ACTION = Right PATH-COST = 6 
Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
82 Chapter 3. Solving Problems by Searching 
of edges (links). This is appropriate when the graph is an explicit data structure that is input to the search program. (The map of Romania is an example of this.) In AI, the graph is often represented implicitly by the initial state, actions, and transition model and is frequently infi- nite. For these reasons, complexity is expressed in terms of three quantities: b, the branching 
BRANCHING FACTOR factor or maximum number of successors of any node; d, the depth of the shallowest goal DEPTH node (i.e., the number of steps along the path from the root); and m, the maximum length of any path in the state space. Time is often measured in terms of the number of nodes generated during the search, and space in terms of the maximum number of nodes stored in memory. For the most part, we will describe time and space complexity for search on a tree; for a graph, the answer will depend on how “redundant” the paths in the state space are. 
SEARCH COST 
To assess the effectiveness of a search algorithm, we can consider just the search cost— which typically depends on the time complexity but can also include a term for memory 
TOTAL COST 
usage—or we can use the total cost, which combines the search cost and the path cost of the solution found. For the problem of finding a route from Arad to Bucharest, the search cost is the amount of time taken by the search and the solution cost is the total length of the path in kilometers. Thus, to compute the total cost, we have to add milliseconds and kilometers. There is no “official exchange rate” between the two, but it might be reasonable in this case to convert kilometers into milliseconds by using an estimate of the car’s average speed (because time is what the agent cares about). This enables the agent to find an optimal tradeoff point at which further computation to find a shorter path becomes counterproductive. The more general problem of tradeoffs between different goods will be taken up in Chapter 16. 
3.4 UNINFORMED SEARCH STRATEGIES 
This section covers several search strategies that come under the heading of uninformed UNINFORMED SEARCH search (also called blind search). The term means that they have no additional informa- BLIND SEARCH tion about states beyond that provided in the problem definition. All they can do is generate successors and distinguish a goal state from a nongoal state. All search strategies are dis- tinguished by the order in which nodes are expanded. Strategies that know whether one 
INFORMED SEARCH non-goal state is “more promising” than another are called informed search or heuristic HEURISTIC SEARCH 
search strategies; they will be covered in Section 3.5. 3.4.1 Breadth-first search 
BREADTH-FIRST SEARCH Breadth-first search is a simple strategy in which the root node is expanded first, then all the successors of the root node are expanded next, then their successors, and so on. In general, all the nodes are expanded at a given depth in the search tree before any nodes at the next level are expanded. 
Breadth-first search is an instance of the general graph search algorithm (Figure 3.7) in which the shallowest unexpanded node is chosen for expansion. This is achieved very simply by using a FIFO queue for the frontier. Thus, new nodes (which are always deeper than their parents) go to the back of the queue and old nodes, which are shallower than the new nodes, 
AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE 
DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
Section 3.4. Uninformed Search Strategies 83 
get expanded first. There is one slight tweak on the general graph search algorithm, which is that the goal test is applied to each node when it is generated, rather than when it is selected for expansion. This decision is explained below, where we discuss time complexity. Note also that the algorithm, following the general template for graph search, discards any new path to a state already in the frontier or explored set; it is easy to see that any such path must be at least as deep as the one already found. Thus, breadth-first search always has the shallowest path to every node on the frontier. 
Pseudocode is given in Figure 3.11. Figure 3.12 shows the progress of the search on a simple binary tree. 
How does breadth-first search rate according to the four criteria from the previous sec- tion? We can easily see that it is complete—if the shallowest goal node is at some finite depth d, breadth-first search will eventually find it after generating all shallower nodes (provided the branching factor b is finite). Note that as soon as a goal node is generated, we know it is the shallowest goal node because all shallower nodes must have been generated already and failed the goal test. Now, the shallowest goal node is not necessarily the optimal one; technically, breadth-first search is optimal if the path cost is a nondecreasing function of the depth of the node. The most common such scenario is when all actions have the same cost. 
A A 
A 
A 
A 
B C 
B C 
D E F G 
D E F G 
B 
B 
C 
C 
C 
D E F G 
D E F G 
B C 
B C 
B C 
B C 
E F G D 
E F G D 
E F G D 
function BREADTH-FIRST-SEARCH(problem) returns a solution, or failure 
node ←a node with STATE = problem.INITIAL-STATE, PATH-COST = 0 if problem.GOAL-TEST(node.STATE) then return SOLUTION(node) frontier ←a FIFO queue with node as the only element explored ←an empty set loop do 
if EMPTY?(frontier) then return failure node ←POP(frontier) /* chooses the shallowest node in frontier */ add node.STATE to explored for each action in problem.ACTIONS(node.STATE) do child ← CHILD-NODE(problem,node,action) if child.STATE is not in explored or frontier then do 
if problem.GOAL-TEST(child.STATE) then return SOLUTION(child) frontier ←INSERT(child,frontier) 
Figure 3.11 Breadth-first search on a graph. 
Figure 3.12 Breadth-first search on a simple binary tree. At each stage, the node to be expanded next is indicated by a marker. 
AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE 
Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
84 Chapter 3. Solving Problems by Searching 
DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
So far, the news about breadth-first search has been good. The news about time and space is not so good. Imagine searching a uniform tree where every state has b successors. The root of the search tree generates b nodes at the first level, each of which generates b more nodes, for a total of b2 at the second level. Each of these generates b more nodes, yielding b3 nodes at the third level, and so on. Now suppose that the solution is at depth d. In the worst case, it is the last node generated at that level. Then the total number of nodes generated is 
b + b2 + b3 + ··· + bd = O(bd) . 
(If the algorithm were to apply the goal test to nodes when selected for expansion, rather than when generated, the whole layer of nodes at depth d would be expanded before detecting the goal, and the time complexity would be O(bd+1).) 
As for space complexity: for any kind of graph search, which stores every expanded node in the explored set, the space complexity is always within a factor of b of the time complexity. For breadth-first graph search in particular, every node generated remains in memory. There will be O(bd−1) nodes in the explored set and O(bd) nodes in the frontier, so the space complexity is O(bd), i.e., it is dominated by the size of the frontier. Switching to a tree search would not save much space, and in a state space with many redundant paths it could cost a great deal of time. 
An exponential complexity bound such as O(bd) is scary. Figure 3.13 shows why. It lists the time and memory required for a breadth-first search with branching factor b = 10, for various values of the solution depth d. The table assumes that 100,000 nodes can be generated per second and that a node requires 1000 bytes of storage. Many search problems fit roughly within these assumptions (give or take a factor of 100) when run on a modern personal computer. 
There are two lessons to be learned from Figure 3.13. First, the memory requirements are a bigger problem for breadth-first search than is the execution time. 31 hours would not be too long to wait for the solution to an important problem of depth 10, but few computers have the 10 terabytes of main memory it would take. Fortunately, there are other search strategies that require less memory. 
AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE 
Depth Nodes Time Memory 
Figure 3.13 Time and memory requirements for breadth-first search. The numbers shown assume branching factor b = 10; 100,000 nodes/second; 1000 bytes/node. 
10 1010 31 hours 10 terabytes 
12 1012 129 days 1 petabytes 
14 1014 35 years 99 petabytes 
16 1016 3,500 years 10 exabytes 
2 110 1.1 milliseconds 107 kilobytes 
4 11,110 111 milliseconds 10.6 megabytes 
6 106 11 seconds 1 gigabytes 
8 108 19 minutes 103 gigabytes 
Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
Section 3.4. Uninformed Search Strategies 85 
The second lesson is that the time requirements are still a major factor. If your problem has a solution at depth 16, then (given our assumptions) it will take about 3,500 years for breadth-first search (or indeed any uninformed search) to find it. In general, exponential- complexity search problems cannot be solved by uninformed methods for any but the smallest instances. 
3.4.2 Uniform-cost search 
Breadth-first search is optimal when all step costs are equal, because it always expands the shallowest unexpanded node. By a simple extension, we can find an algorithm that is optimal with any step cost function. Instead of expanding the shallowest node, uniform-cost search UNIFORM-COST SEARCH expands the node n with the lowest path cost g(n). This is done by storing the frontier as a 
priority queue ordered by g. The algorithm is shown in Figure 3.14. 
In addition to the ordering of the queue by path cost, there are two other significant differences from breadth-first search. The first is that the goal test is applied to a node when it is selected for expansion (as in the generic graph search algorithm shown in Figure 3.7) rather than when it is first generated. The reason is that the first goal node that is generated may be on a suboptimal path. The second difference is that a test is added in case a better path is found to a node currently on the frontier. 
Both of these modifications come into play in the example shown in Figure 3.15, where the problem is to get from Sibiu to Bucharest. The successors of Sibiu are Rimnicu Vilcea and Fagaras, with costs 80 and 99 respectively. The least-cost node, Rimnicu Vilcea, is expanded 
AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE 
function UNIFORM-COST-SEARCH(problem) returns a solution, or failure 
node ←a node with STATE = problem.INITIAL-STATE, PATH-COST = 0 frontier ←a priority queue ordered by PATH-COST, with node as the only element explored ←an empty set loop do 
if EMPTY?(frontier) then return failure node ←POP(frontier) /* chooses the lowest-cost node in frontier */ if problem.GOAL-TEST(node.STATE) then return SOLUTION(node) for each action in problem.ACTIONS(node.STATE) do child ← CHILD-NODE(problem,node,action) if child.STATE is not in explored or frontier then 
add child.STATE to explored frontier ←INSERT(child,frontier) else if child.STATE is in frontier with higher PATH-COST then 
replace that frontier node with child 
Figure 3.14 Uniform-cost search on a graph. The algorithm is identical to the general graph search algorithm in Figure 3.7, except for the use of a priority queue and the addition of an extra check in case a shorter path is discovered to a frontier state. The data structure for explored needs to support efficient membership testing, so it should combine the capabilities of a priority queue and a hash table. 
Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
86 Chapter 3. Solving Problems by Searching 
DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
next, adding Pitesti with cost 80+97 = 177. The least-cost node is now Fagaras, so it is expanded, adding Bucharest with cost 99+211 = 310. Now a goal node has been generated, but uniform-cost search keeps going, choosing Pitesti for expansion and adding a second path to Bucharest with cost 80+97+101 = 278. Now the algorithm checks to see if this new path is better than the old one; it is, so the old one is discarded. Bucharest, now with g-cost 278, is selected for expansion and the solution is returned. 
It is easy to see that uniform-cost search is optimal in general. First, we observe that whenever uniform-cost search selects a node n for expansion, the optimal path to that node has been found. (Were this not the case, there would have to be another frontier node n′ on the optimal path from the start node to n, by the graph separation property of Figure 3.9; by definition, n′ would have lower g-cost than n and would have been selected first.) Then, because step costs are non-negative, paths never get shorter as nodes are added. These two facts together imply that uniform-cost search expands nodes in order of their optimal path cost. Hence, the first goal node selected for expansion must be the optimal solution. 
Uniform-cost search does not care about the number of steps a path has, but only about their total cost. Therefore, it will get stuck in an infinite loop if there is a path with an infinite sequence of zero-cost actions—for example, a sequence of NoOp actions.6 Completeness is guaranteed provided the cost of every step is greater than or equal to some small positive constant ǫ. 
Uniform-cost search is guided by path costs rather than depths, so its complexity cannot easily be characterized in terms of b and d. Instead, let C∗ be the cost of the optimal solution, and assume that every action costs at least ǫ. Then the algorithm’s worst-case time and space complexity is O(b1+⌊C*/ǫ⌋), which can be much greater than bd. This is because uniform-cost search can, and often does, explore large trees of small steps before exploring paths involving large and perhaps useful steps. When all step costs are equal, b1+⌊C*/ǫ⌋ is just bd+1. Notice that this is slightly worse than the bd complexity for breadth-first search, because the latter applies the goal test to each node as it is generated and so does not expand nodes at depth d. 
6 NoOp, or “no operation,” is the name of an assembly language instruction that does nothing. 
AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE 
Figure 3.15 A portion of the Romania state space, selected to illustrate uniform-cost search. 
Sibiu 99 
Fagaras 
80 
Rimnicu Vilcea 
97 
Pitesti 
211 
101 
Bucharest 
Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
Section 3.4. Uninformed Search Strategies 87 
3.4.3 Depth-first search 
Depth-first search always expands the deepest node in the current frontier of the search tree. DEPTH-FIRST SEARCH The progress of the search is illustrated in Figure 3.16. The search proceeds immediately to the deepest level of the search tree, where the nodes have no successors. As those nodes are expanded, they are dropped from the frontier, so then the search “backs up” to the next deepest node that still has unexplored successors. 
The depth-first search algorithm is an instance of the graph search algorithm in Fig- ure 3.7; whereas breadth-first-search uses a FIFO queue, depth-first search uses a LIFO queue. A LIFO queue means that the most recently generated node is chosen for expansion. This must be the deepest unexpanded node, because it is one deeper that its parent—which, in turn, was the deepest unexpanded node when it was selected. 
As an alternative to the GRAPH-SEARCH-style implementation, it is common to im- plement depth-first search with a recursive function that calls itself on each of its children in turn. (A recursive depth-first algorithm incorporating a depth limit is shown in Figure 3.17.) 
AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE 
Figure 3.16 Depth-first search on a binary tree. The unexplored region is shown in light gray. Explored nodes with no descendants in the frontier are removed from memory. Nodes at depth 3 have no successors, and M is the only goal node. 
A 
B C 
D E F G 
H I J K L M N O 
A 
B C 
D E F G 
H I J K L M N O 
A 
C 
E F G 
J K L M N O 
A 
C 
F G 
L M N O 
A 
B C 
D E F G 
H I J K L M N O 
A 
B C 
D E F G 
I J K L M N O 
A 
B C 
E F G 
K L M N O 
A 
C 
F G 
L M N O 
A 
A 
B C 
B C 
D E F G 
D E F G 
H I J K L M N O 
H I J K L M N O 
A 
A 
C 
C 
E F G 
E F G 
J K L M N O 
J K L M N O 
A 
A 
C 
C 
F G 
F G 
M N O 
M N O 
C 
C 
F G 
F G 
L M N O 
L M N O 
Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
88 Chapter 3. Solving Problems by Searching 
The properties of depth-first search depend strongly on whether the graph search or tree search version is used. The graph search version, which avoids repeated states and redundant paths, is complete in finite state spaces because it will eventually expand every node. The tree search version, on the other hand, is not complete—for example, in Figure 3.6 the algorithm will follow the Arad–Sibiu–Arad–Sibiu loop forever. Depth-first tree search can be modified at no extra memory cost so that it checks new states against those on the path from the root to the current node; this avoids infinite loops in finite state spaces, but does not avoid the proliferation of redundant paths. In infinite state spaces, both versions fail if an infinite non- goal path is encountered. For example, in Knuth’s 4 problem, depth-first search would keep applying the factorial operator forever. 
For similar reasons, both versions are non-optimal. For example, in Figure 3.16, depth- first search will explore the entire left subtree even if node C is a goal node. If node J were also a goal node, then depth-first search would return it as a solution instead of C, which would be a better solution; hence, depth-first search is not optimal. 
The time complexity of depth-first graph search is bounded by the size of the state space (which may be infinite, of course). A depth-first tree search, on the other hand, may generate all of the O(bm) nodes in the search tree, where m is the maximum depth of any node; this can be much greater than the size of the state space. Note that m itself can be much larger than d (the depth of the shallowest solution), and is infinite if the tree is unbounded. 
So far depth-first search seems to have no clear advantage over breadth-first search, so why do we include it? The reason is the space complexity. For a graph search, there is no advantage, but a depth-first tree search needs to store only a single path from the root to a leaf node, along with the remaining unexpanded sibling nodes for each node on the path. Once a node has been expanded, it can be removed from memory as soon as all its descendants have been fully explored. (See Figure 3.16.) For a state space with branching factor b and maximum depth m, depth-first search requires storage of only O(bm) nodes. Using the same assumptions as Figure 3.13, and assuming that nodes at the same depth as the goal node have no successors, we find that depth-first search would require 156 kilobytes instead of 10 exabytes at depth d = 16, a factor of 7 trillion times less space. This has led to the adoption of depth-first tree search as the basic workhorse of many areas of AI, including constraint satisfaction (Chapter 6), propositional satisfiability (Chapter 7), and logic programming (Chapter 9). For the remainder of this chapter, we will focus primarily on the tree search version of depth-first search. BACKTRACKING SEARCH A variant of depth-first search called backtracking search uses still less memory. (See Chapter 6 for more details.) In backtracking, only one successor is generated at a time rather than all successors; each partially expanded node remembers which successor to generate next. In this way, only O(m) memory is needed rather than O(bm). Backtracking search facilitates yet another memory-saving (and time-saving) trick: the idea of generating a suc- cessor by modifying the current state description directly rather than copying it first. This reduces the memory requirements to just one state description and O(m) actions. For this to work, we must be able to undo each modification when we go back to generate the next suc- cessor. For problems with large state descriptions, such as robotic assembly, these techniques are critical to success. 
AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE 
DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
Section 3.4. Uninformed Search Strategies 89 
3.4.4 Depth-limited search 
The embarrassing failure of depth-first search in infinite state spaces can be alleviated by supplying depth-first search with a predetermined depth limit l. That is, nodes at depth l are treated as if they have no successors. This approach is called depth-limited search. The DEPTH-LIMITED SEARCH depth limit solves the infinite-path problem. Unfortunately, it also introduces an additional source of incompleteness if we choose l<d, that is, the shallowest goal is beyond the depth limit. (This is not unlikely when d is unknown.) Depth-limited search will also be nonoptimal if we choose l>d. Its time complexity is O(bl) and its space complexity is O(bl). Depth- first search can be viewed as a special case of depth-limited search with l=∞. 
Sometimes, depth limits can be based on knowledge of the problem. For example, on the map of Romania there are 20 cities. Therefore, we know that if there is a solution, it must be of length 19 at the longest, so l = 19 is a possible choice. But in fact if we studied the map carefully, we would discover that any city can be reached from any other city in at most 9 steps. This number, known as the diameter of the state space, gives us a better depth limit, DIAMETER which leads to a more efficient depth-limited search. For most problems, however, we will not know a good depth limit until we have solved the problem. 
Depth-limited search can be implemented as a simple modification to the general tree or graph search algorithm. Alternatively, it can be implemented as a simple recursive algorithm as shown in Figure 3.17. Notice that depth-limited search can terminate with two kinds of failure: the standard failure value indicates no solution; the cutoff value indicates no solution within the depth limit. 
3.4.5 Iterative deepening depth-first search 
Iterative deepening search (or iterative deepening depth-first search) is a general strategy, ITERATIVE DEEPENING SEARCH often used in combination with depth-first tree search, that finds the best depth limit. It does 
AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE 
function DEPTH-LIMITED-SEARCH(problem,limit) returns a solution, or failure/cutoff return RECURSIVE-DLS(MAKE-NODE(problem.INITIAL-STATE),problem,limit) 
function RECURSIVE-DLS(node,problem,limit) returns a solution, or failure/cutoff 
if problem.GOAL-TEST(node.STATE) then return SOLUTION(node) else if limit = 0 then return cutoff elsecutoff 
occurred?←true else if result = failure then return result if cutoff 
Figure 3.17 A recursive implementation of depth-limited tree search. 
occurred?←false for each action in problem.ACTIONS(node.STATE) do child ←CHILD-NODE(problem,node,action) result ← RECURSIVE-DLS(child,problem,limit − 1) if result = cutoff then cutoff 
occurred? then return cutoff else return failure 
Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
90 Chapter 3. Solving Problems by Searching 
this by gradually increasing the limit—first 0, then 1, then 2, and so on—until a goal is found. This will occur when the depth limit reaches d, the depth of the shallowest goal node. The algorithm is shown in Figure 3.18. Iterative deepening combines the benefits of depth-first and breadth-first search. Like depth-first search, its memory requirements are very modest: O(bd) to be precise. Like breadth-first search, it is complete when the branching factor is finite and optimal when the path cost is a nondecreasing function of the depth of the node. Figure 3.19 shows four iterations of ITERATIVE-DEEPENING-SEARCH on a binary search tree, where the solution is found on the fourth iteration. 
Iterative deepening search may seem wasteful, because states are generated multiple times. It turns out this is not very costly. The reason is that in a search tree with the same (or nearly the same) branching factor at each level, most of the nodes are in the bottom level, so it does not matter much that the upper levels are generated multiple times. In an iterative deepening search, the nodes on the bottom level (depth d) are generated once, those on the next to bottom level are generated twice, and so on, up to the children of the root, which are generated d times. So the total number of nodes generated in the worst case is 
N(IDS)=(d)b + (d − 1)b2 + ··· + (1)bd , 
which gives a time complexity of O(bd)—asymptotically the same as breadth-first search. There is some extra cost for generating the upper levels multiple times, but it is not large. For example, if b = 10 and d = 5, the numbers are 
N(IDS) = 50+400+3,000 + 20,000 + 100,000 = 123,450 N(BFS) = 10+100+1,000 + 10,000 + 100,000 = 111,110 . 
In general, iterative deepening is the preferred uninformed search method when there is a large search space and the depth of the solution is not known. 
Iterative deepening search is analogous to breadth-first search in that it explores a com- plete layer of new nodes at each iteration before going on to the next layer. It would seem worthwhile to develop an iterative analog to uniform-cost search, inheriting the latter algo- rithm’s optimality guarantees while avoiding its memory requirements. The idea is to use increasing path-cost limits instead of increasing depth limits. The resulting algorithm, called ITERATIVE LENGTHENING SEARCH iterative lengthening search, is explored in Exercise 3.24. It turns out, unfortunately, that iterative lengthening incurs substantial overhead compared to uniform-cost search. 
DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE 
function ITERATIVE-DEEPENING-SEARCH(problem) returns a solution, or failure 
for depth = 0 to ∞ do 
result ←DEPTH-LIMITED-SEARCH(problem,depth) if result = cutoff then return result 
Figure 3.18 The iterative deepening search algorithm, which repeatedly applies depth- limited search with increasing limits. It terminates when a solution is found or if the depth- limited search returns failure, meaning that no solution exists. 
Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
Section 3.4. Uninformed Search Strategies 91 
3.4.6 Bidirectional search 
The idea behind bidirectional search is to run two simultaneous searches—one forward from the initial state and the other backward from the goal—stopping when the two searches meet in the middle (Figure 3.20). The motivation is that bd/2 + bd/2 is much less than bd, or in the figure, the area of the two small circles is less than the area of one big circle centered on the start and reaching to the goal. 
Bidirectional search is implemented by replacing the goal test with a check to see whether the frontiers of the two searches intersect; if they do, a solution has been found. The check can be done when each node is generated or selected for expansion, and with a hash table the check will take constant time. For example, if a problem has solution depth d=6, and each direction runs breadth-first search one node at a time, then in the worst case the two 
AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE 
Limit = 0 A A 
Limit = 1 
A 
A 
A 
B C 
B C 
A 
A 
A 
B C 
B C 
A 
A 
A 
A 
B C 
B C 
B C 
Limit = 2 
Limit = 3 
A 
A 
A 
A 
A 
A 
A 
A 
A 
A 
A 
A 
A 
A 
A 
A 
A 
A 
A 
A 
Figure 3.19 Four iterations of iterative deepening search on a binary tree. 
B C 
D E F G 
B C 
B C 
B C 
B C 
B C 
B C 
D E F G 
D E F G 
D E F G 
D E F G 
D E F G 
D E F G 
A 
B C 
D E F G 
A 
A 
A 
A 
A 
A 
B C 
B C 
B C 
B C 
B C 
B C 
D E F G 
D E F G 
D E F G 
D E F G 
D E F G 
D E F G 
B C 
B C 
B C 
B C 
B C 
B C 
B C 
D E F G 
D E F G 
D E F G 
D E F G 
D E F G 
D E F G 
D E F G 
H I 
J K L M N O H I J K L M N O 
H I J K L M N O 
H I J K L M N O 
H I J K L M N O 
H I J K L M N O 
H I J K L M N O 
A 
A 
A 
A 
A 
A 
A 
B C 
B C 
B C 
B C 
B C 
B C 
B C 
D E F G 
D E F G 
D E F G 
D E F G 
D E F G 
D E F G 
D E F G 
H I J K L M N O 
H I J K L M N O 
H I J K L M N O 
H I J K L M N O 
H I J K L M N O 
H I J K L M N O 
H I J K L M N O 
A 
A 
A 
A 
A 
A 
A 
B C 
B C 
B C 
B C 
B C 
B C 
B C 
D E F G 
D E F G 
D E F G 
D E F G 
D E F G 
D E F G 
D E F G 
H I J K L M N O 
H I J K L M N O 
H I J K L M N O 
H I J K L M N O 
H I J K L M N O 
H I J K L M N O 
H I J K L M N O 
Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
92 Chapter 3. Solving Problems by Searching 
searches meet when they have generated all of the nodes at depth 3. For b= 10, this means a total of 2,220 node generations, compared with 1,111,110 for a standard breadth-first search. Thus, the time complexity of bidirectional search using breadth-first searches in both direc- tions is O(bd/2). The space complexity is also O(bd/2). We can reduce this by roughly half if one of the two searches is done using iterative deepening, but at least one of the frontiers must be kept in memory so that the intersection check can be done. This space requirement is the most significant weakness of bidirectional search. The algorithm is complete and optimal (for uniform step costs) if both searches are breadth-first; other combinations may sacrifice completeness, optimality, or both. 
The reduction in time complexity makes bidirectional search attractive, but how do we 
PREDECESSORS 
search backward? This is not as easy as it sounds. Let the predecessors of a state x be all those states that have x as a successor. Bidirectional search requires a method for computing predecessors. The easiest case is when all the actions in the state space are reversible, so that the predecessors of x are the same as its successors. Other cases may require substantial ingenuity. 
Consider the question of what we mean by “the goal” in searching “backward from the goal.” For the 8-puzzle and for finding a route in Romania, there is just one goal state, so the backward search is very much like the forward search. If there are several explicitly listed goal states—for example, the two dirt-free goal states in Figure 3.3—then we can construct a new dummy goal state whose immediate predecessors are all the actual goal states. Alternatively, some redundant node generations can be avoided by viewing the set of goal states as a single state, each of whose predecessors is also a set of states—specifically, the set of states having a corresponding successor in the set of goal states. (See also Section 4.3.) 
The most difficult case for bidirectional search is when the goal test gives only an im- plicit description of some possibly large set of goal states—for example, all the states that are solutions to the n-queens problem. A backward search would need to construct compact descriptions of “all states that are one queen away from being solutions” and so on; and those descriptions would have to be tested against the states generated by the forward search. There is no general way to do this efficiently. 
AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE 
DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
Figure 3.20 A schematic view of a bidirectional search that is about to succeed, when a branch from the start node meets a branch from the goal node. 
Goal Start 
Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
Section 3.5. Informed (Heuristic) Search Strategies 93 
This section shows how aninformed search strategy—one that uses problem-specific knowl- INFORMED SEARCH edge beyond the definition of the problem itself—can find solutions more efficiently than an uninformed strategy. The general approach we will consider is called best-first search. Best-first search is BEST-FIRST SEARCH an instance of the general TREE-SEARCH or GRAPH-SEARCH algorithm in which a node is selected for expansion based on an evaluation function, f(n). The evaluation function is EVALUATION FUNCTION construed as a cost estimate, so the node with the lowest evaluation is expanded first. The implementation of best-first search is identical to that for uniform-cost search (Figure 3.14), except for the use of f instead of g to order the priority queue. 
The choice of f determines the search strategy. (In fact, as Exercise 3.33 shows, best- first search includes breadth-first, depth-first, and uniform-cost search as special cases.) Most best-first algorithms include as a component of f a heuristic function, denoted h(n): HEURISTIC FUNCTION 
h(n) = estimated cost of the cheapest path from the state at node n to a goal state. 
(Notice that h(n) takes a node as input, but, unlike g(n), it depends only on the state at that node.) For example, in Romania, one might estimate the cost of the cheapest path from Arad to Bucharest via the straight-line distance from Arad to Bucharest. 
Heuristic functions are the most common form in which additional knowledge of the problem is imparted to the search algorithm. We will study heuristics in more depth in Sec- tion 3.6. For now, we will consider them to be arbitrary, non-negative, problem-specific 
AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE 
3.5 INFORMED (HEURISTIC) SEARCH STRATEGIES 
3.4.7 Comparing uninformed search strategies 
Figure 3.21 compares search strategies in terms of the four evaluation criteria set forth in Section 3.4. This comparison is for tree-search versions. For graph searches, the main dif- ferences are that depth-first search is complete for finite state spaces, and that the space and time complexities are bounded by the size of the state space. 
Criterion 
Complete? 
Time 
Space 
Optimal? 
Breadth- Uniform- Depth- Depth- Iterative Bidirectional 
O(bd) O(b1+IC*/ǫj) O(bm) O(bl) O(bd) O(bd/2) 
O(bd) O(b1+IC*/ǫj) O(bm) O(bl) O(bd) O(bd/2) 
Yesa Yesa,b No No Yesa Yesa,d 
Yesc Yes No No Yesc Yesc,d 
First Cost First Limited Deepening (if applicable) 
Figure 3.21 Evaluation of tree-search strategies. b is the branching factor; d is the depth of the shallowest solution; m is the maximum depth of the search tree; l is the depth limit. Superscript caveats are as follows: a complete if b is finite; b complete if step costs ≥ ǫ for positive ǫ; c optimal if step costs are all identical; d if both directions use breadth-first search. 
Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
94 Chapter 3. Solving Problems by Searching 
functions, with one constraint: if n is a goal node, then h(n)=0. The remainder of this section covers two ways to use heuristic information to guide search. 
3.5.1 Greedy best-first search 
GREEDY BEST-FIRST SEARCH Greedy best-first search7 tries to expand the node that is closest to the goal, on the grounds that this is likely to lead to a solution quickly. Thus, it evaluates nodes by using just the 
heuristic function: f(n) = h(n). 
Let us see how this works for route-finding problems in Romania, using the straight- STRAIGHT-LINE DISTANCE line distance heuristic, which we will call hSLD. If the goal is Bucharest, we will need to know the straight-line distances to Bucharest, which are shown in Figure 3.22. For example, hSLD(In(Arad)) = 366. Notice that the values of hSLD cannot be computed from the prob- lem description itself. Moreover, it takes a certain amount of experience to know that hSLD is correlated with actual road distances and is, therefore, a useful heuristic. 
DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
Figure 3.23 shows the progress of a greedy best-first search using hSLD to find a path from Arad to Bucharest. The first node to be expanded from Arad will be Sibiu, because it is closer to Bucharest than either Zerind or Timisoara. The next node to be expanded will be Fagaras, because it is closest. Fagaras in turn generates Bucharest, which is the goal. For this particular problem, greedy best-first search using hSLD finds a solution without ever expanding a node that is not on the solution path; hence, its search cost is minimal. It is not optimal, however: the path via Sibiu and Fagaras to Bucharest is 32 kilometers longer than the path through Rimnicu Vilcea and Pitesti. This shows why the algorithm is called “greedy”—at each step it tries to get as close to the goal as it can. 
Greedy best-first tree search is also incomplete even in a finite state space, much like depth-first search. Consider the problem of getting from Iasi to Fagaras. The heuristic sug- gests that Neamt be expanded first, because it is closest to Fagaras, but it is a dead end. The solution is to go first to Vaslui—a step that is actually farther from the goal according to the heuristic—and then to continue to Urziceni, Bucharest, and Fagaras. The algorithm will never find this solution, however, because expanding Neamt puts Iasi back into the frontier, 
7 Our first edition called this greedy search; other authors have called it best-first search. Our more general usage of the latter term follows Pearl (1984). 
AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE 
Figure 3.22 Values of hSLD—straight-line distances to Bucharest. 
Arad Bucharest Craiova Drobeta Eforie Fagaras Giurgiu Hirsova Iasi Lugoj 
366 0 160 242 161176 77 151 226 244 
Mehadia Neamt Oradea Pitesti Rimnicu Vilcea Sibiu Timisoara Urziceni Vaslui Zerind 
Mehadia Neamt Oradea Pitesti Rimnicu Vilcea Sibiu Timisoara Urziceni Vaslui Zerind 
241 234 380 100 193 253 32980 199 374 
241 234 380 100 193 253 32980 199 374 
241 234 380 100 193 253 32980 199 374 
Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
Section 3.5. Informed (Heuristic) Search Strategies 95 
Iasi is closer to Fagaras than Vaslui is, and so Iasi will be expanded again, leading to an infi- nite loop. (The graph search version is complete in finite spaces, but not in infinite ones.) The worst-case time and space complexity for the tree version is O(bm), where m is the maximum depth of the search space. With a good heuristic function, however, the complexity can be reduced substantially. The amount of the reduction depends on the particular problem and on the quality of the heuristic. 
3.5.2 A* search: Minimizing the total estimated solution cost 
The most widely-known form of best-first search is called A∗ search (pronounced “A-star A∗ SEARCH search”). It evaluates nodes by combining g(n), the cost to reach the node, and h(n), the cost 
AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE 
(a) The initial state 
(b) After expanding Arad 
(c) After expanding Sibiu 
(d) After expanding Fagaras 
Arad 
Sibiu 
Arad Fagaras Oradea 
Arad 
Arad 
Arad 
Zerind Timisoara 
Rimnicu Vilcea 
Figure 3.23 Stages in a greedy best-first tree search for Bucharest using the straight-line distance heuristic hSLD. Nodes are labeled with their h-values. 
366 
Sibiu Timisoara 
Zerind 
253 329 374 
Sibiu 
Arad Fagaras Oradea 
Timisoara 
329 
Zerind 
Zerind 
374 
Rimnicu Vilcea 
366 176 380 193 
Sibiu Bucharest 
329 374 
366 380 193 
253 0 
Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
96 Chapter 3. Solving Problems by Searching 
to get from the node to the goal: 
f(n) = g(n) + h(n) . Since g(n) gives the path cost from the start node to node n, and h(n) is the estimated cost of the cheapest path from n to the goal, we have 
f(n) = estimated cost of the cheapest solution through n . Thus, if we are trying to find the cheapest solution, a reasonable thing to try first is the node with the lowest value of g(n) + h(n). It turns out that this strategy is more than just reasonable: provided that the heuristic function h(n) satisfies certain conditions, A∗ search is both complete and optimal. The algorithm is identical to UNIFORM-COST-SEARCH except that A∗ uses g + h instead of g. 
Conditions for optimality: Admissibility and consistency 
ADMISSIBLE HEURISTIC The first condition we require for optimality is that h(n) be an admissible heuristic. An admissible heuristic is one that never overestimates the cost to reach the goal. Because g(n) is the actual cost to reach n, and f(n)=g(n) + h(n), we have as immediate consequence that f(n) never overestimates the true cost of a solution through n. 
Admissible heuristics are by nature optimistic, because they think the cost of solving the problem is less than it actually is. An obvious example of an admissible heuristic is the straight-line distance hSLD that we used in getting to Bucharest. Straight-line distance is admissible because the shortest path between any two points is a straight line, so the straight line cannot be an overestimate. In Figure 3.24, we show the progress of an A∗ tree search for Bucharest. The values of g are computed from the step costs in Figure 3.2, and the values of hSLD are given in Figure 3.22. Notice in particular that Bucharest first appears on the frontier at step (e), but it is not selected for expansion because its f-cost (450) is higher than that of Pitesti (417). Another way to say this is that there might be a solution through Pitesti whose cost is as low as 417, so the algorithm will not settle for a solution that costs 450. 
CONSISTENCY A second, slightly stronger condition called consistency (or sometimes monotonicity) MONOTONICITY is required only for the graph-search version of A∗. A heuristic h(n) is consistent if, for every node n and every successor n′ of n generated by any action a, the estimated cost of reaching the goal from n is no greater than the step cost of getting to n′ plus the estimated cost of reaching the goal from n′: 
h(n) ≤ c(n, a, n′) + h(n′) . 
TRIANGLE INEQUALITY This is a form of the general triangle inequality, which stipulates that each side of a triangle cannot be longer than the sum of the other two sides. Here, the triangle is formed by n, n′, and the goal Gn closest to n. For an admissible heuristic, the inequality makes perfect sense: if there were a route from n to Gn via n′ that was cheaper than h(n), that would violate the property that h(n) is a lower bound on the cost to reach Gn. 
It is fairly easy to show (Exercise 3.37) that every consistent heuristic is also admissible. Consistency is therefore a stricter requirement than admissibility, but one has to work quite hard to concoct heuristics that are admissible but not consistent. All the admissible heuristics we discuss in this chapter are also consistent. Consider, for example, hSLD. We know that 
AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE 
DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
Section 3.5. Informed (Heuristic) Search Strategies 97 
Figure 3.24 Stages in an A∗ search for Bucharest. Nodes are labeled with f = g +h. The h values are the straight-line distances to Bucharest taken from Figure 3.22. 
AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE 
(a) The initial state 
(b) After expanding Arad 
(c) After expanding Sibiu 
Arad 366=0+366 
(d) After expanding Rimnicu Vilcea 
(e) After expanding Fagaras 
(f) After expanding Pitesti 
Arad 
Sibiu Timisoara 
447=118+329 
Zerind 393=140+253 
449=75+374 Arad 
Sibiu 
Arad 
Timisoara 
Fagaras Oradea 
Rimnicu Vilcea Zerind 
447=118+329 449=75+374 
646=280+366 415=239+176 671=291+380 
413=220+193 Arad 
Sibiu Timisoara 
Zerind 447=118+329 449=75+374 
Arad Fagaras Oradea 
Rimnicu Vilcea 646=280+366 415=239+176 671=291+380 
Craiova Pitesti Sibiu 526=366+160 417=317+100 
553=300+253 Arad 
Sibiu 
Zerind 
Arad 
Timisoara 
Sibiu Bucharest 
447=118+329 449=75+374 
Fagaras Oradea 
Rimnicu Vilcea 646=280+366 
671=291+380 
Craiova Pitesti Sibiu 591=338+253 450=450+0 526=366+160 417=317+100 
553=300+253 Arad 
Sibiu 
Zerind 
Arad 
Fagaras Rimnicu Vilcea 
Timisoara 
Oradea 
Sibiu BucharestCraiova Pitesti Sibiu 
Bucharest Craiova Rimnicu Vilcea 418=418+0 
447=118+329 449=75+374 
646=280+366 
671=291+380 
591=338+253 450=450+0 526=366+160 553=300+253 
615=455+160 607=414+193 
Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
98 Chapter 3. Solving Problems by Searching 
the general triangle inequality is satisfied when each side is measured by the straight-line distance, and that the straight-line distance between n and n′ is no greater than c(n, a, n′). Hence, hSLD is a consistent heuristic. 
Optimality of A* 
As we mentioned earlier, A∗ has the following properties: the tree-search version of A∗ is optimal if h(n) is admissible, while the graph-search version is optimal if h(n) is consistent. We will show the second of these two claims, since it is more useful. The argument essentially mirrors the argument for the optimality of uniform-cost search, with g replaced by f—just as in the A∗ algorithm itself. 
The first step is to establish the following: if h(n) is consistent, then the values of f(n) along any path are nondecreasing. The proof follows directly from the definition of consistency. Suppose n′ is a successor of n; then g(n′)= g(n) + c(n, a, n′) for some a, and we havef(n′) = g(n′) + h(n′) = g(n) + c(n, a, n′) + h(n′) ≥ g(n) + h(n) = f(n) . The next step is to prove that whenever A∗ selects a node n for expansion, the optimal path to that node has been found. Were this not the case, there would have to be another frontier node n′ on the optimal path from the start node to n, by the graph separation property of Figure 3.9; because f is nondecreasing along any path, n′ would have lower f-cost than n and would have been selected first. 
From the two preceding observations, it follows that the sequence of nodes expanded by A∗ using GRAPH-SEARCH is in nondecreasing order of f(n). Hence, the first goal node selected for expansion must be an optimal solution, because f is the true cost for goal nodes (which have h=0) and all later goal nodes will be at least as expensive. 
The fact that f-costs are nondecreasing along any path also means that we can draw 
CONTOURS 
contours in the state space, just like the contours in a topographic map. Figure 3.25 shows an example. Inside the contour labeled 400, all nodes have f(n) less than or equal to 400, and so on. Then, because A∗ expands the frontier node of lowest f-cost, we can see that an A∗ search fans out from the start node, adding nodes in concentric bands of increasing f-cost. With uniform-cost search (A∗ search using h(n) = 0), the bands will be “circular” around the start state. With more accurate heuristics, the bands will stretch toward the goal state and become more narrowly focused around the optimal path. If C∗ is the cost of the optimal solution path, then we can say the following: 
• A∗ expands all nodes with f(n) < C∗. 
• A∗ might then expand some of the nodes right on the “goal contour” (where f(n) = C∗) before selecting a goal node. 
Completeness requires that there be only finitely many nodes with cost less than or equal to C∗, a condition that is true if all step costs exceed some finite ǫ and if b is finite. 
Notice that A∗ expands no nodes with f(n) > C∗—for example, Timisoara is not expanded in Figure 3.24 even though it is a child of the root. We say that the subtree below 
PRUNING 
Timisoara is pruned; because hSLD is admissible, the algorithm can safely ignore this subtree AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE 
DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
Section 3.5. Informed (Heuristic) Search Strategies 99 
while still guaranteeing optimality. The concept of pruning—eliminating possibilities from consideration without having to examine them—is important for many areas of AI. 
One final observation is that among optimal algorithms of this type—algorithms that extend search paths from the root and use the same heuristic information—A∗ is optimally efficient for any given heuristic function. That is, no other optimal algorithm is guaran- OPTIMALLY EFFICIENT teed to expand fewer nodes than A∗ (except possibly through tie-breaking among nodes with f(n)=C∗). This is because any algorithm that does not expand all nodes with f(n) < C∗ runs the risk of missing the optimal solution. 
That A∗ search is complete, optimal, and optimally efficient among all such algorithms is rather satisfying. Unfortunately, it does not mean that A∗ is the answer to all our searching needs. The catch is that, for most problems, the number of states within the goal contour search space is still exponential in the length of the solution. The details of the analysis are beyond the scope of this book, but the basic results are as follows. For problems with constant step costs, the growth in runtime is analyzed in terms of the the absolute error or the relative ABSOLUTE ERROR error of the heuristic. The absolute error is defined as ∆ ≡ h∗−h, where h∗ is the actual cost RELATIVE ERROR of getting from the root to the goal, and the relative error is defined as ǫ ≡ (h∗ − h)/h∗. For a state space that is a tree, the time complexity of A∗ is exponential in the absolute error, i.e., O(b∆). For constant step costs, we can write this as O(bǫd), where d is the solution depth. For almost all heuristics in practical use, the absolute error is at least proportional to the path cost h∗, so ǫ is constant or growing and the time complexity is exponential in d. We can also see the effect of a more accurate heuristic: O(bǫd)=O((bǫ)d), so the effective branching factor (defined more formally in the next section) is bǫ. 
In the general case of a graph, the situation is even worse: there can be exponentially 
AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE 
Figure 3.25 Map of Romania showing contours at f = 380, f = 400 and f = 420, with Arad as the start state. Nodes inside a given contour have f-costs less than or equal to the contour value. 
O 
Z 
AT 
N 
380 
S F400 
S F400 
R 
I 
V 
V 
LM 
D C 
P 
420 
G 
B U HE 
B U HE 
B U HE 
Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
100 Chapter 3. Solving Problems by Searching 
many states with f(n) < C∗ even if the absolute error is bounded by a constant. For example, consider a simplified version of the vacuum world where the agent can clean up any square for unit cost without even having to visit it: in that case, squares can be cleaned in any order. With N initially dirty squares, there are 2N states where some subset has been cleaned, and all of them are on an optimal solution path—and hence satisfy f(n) < C∗ even if the heuristic has an error of 1. 
The complexity of A∗ often makes it impractical to insist on finding an optimal solution. One can use variants of A∗ that find suboptimal solutions quickly, or one can sometimes design heuristics that are more accurate but not strictly admissible. In any case, the use of a good heuristic still provides enormous savings compared to the use of an uninformed search. In Section 3.6, we will look at the question of designing good heuristics. 
Computation time is not, however, A∗’s main drawback. Because it keeps all generated nodes in memory (as do all GRAPH-SEARCH algorithms), A∗ usually runs out of space long before it runs out of time. For this reason, A∗ is not practical for many large-scale prob- lems. Recently developed algorithms have overcome the space problem without sacrificing optimality or completeness, at a small cost in execution time. We discuss these next. 
3.5.3 Memory-bounded heuristic search 
ITERATIVE- DEEPENING A∗ The simplest way to reduce memory requirements for A∗ is to adapt the idea of iterative deepening to the heuristic search context, resulting in the iterative-deepening A∗ (IDA∗) al- gorithm. The main difference between IDA∗ and standard iterative deepening is that the cutoff used is the f-cost (g+h) rather than the depth; at each iteration, the cutoff value is the small- est f-cost of any node that exceeded the cutoff on the previous iteration. IDA∗ is practical for many problems with unit step costs and avoids the substantial overhead associated with keeping a sorted queue of nodes. Unfortunately, it suffers from the same difficulties with real- valued costs as does the iterative version of uniform-cost search described in Exercise 3.24. This section briefly examines two more recent memory-bounded algorithms, called RBFS and MA∗. RECURSIVE BEST-FIRST SEARCH Recursive best-first search (RBFS) is a simple recursive algorithm that attempts to mimic the operation of standard best-first search, but using only linear space. The algorithm is shown in Figure 3.26. Its structure is similar to that of a recursive depth-first search, but rather than continuing indefinitely down the current path, it uses the f 
limit variable to keep track of the f-value of the best alternative path available from any ancestor of the current node. If the current node exceeds this limit, the recursion unwinds back to the alternative path. As the recursion unwinds, RBFS replaces the f-value of each node along the path 
BACKED-UP VALUE 
with backed-up value—the best f-value of its children. In this way, RBFS remembers the f-value of the best leaf in the forgotten subtree and can therefore decide whether it’s worth reexpanding the subtree at some later time. Figure 3.27 shows how RBFS reaches Bucharest. RBFS is somewhat more efficient than IDA∗, but still suffers from excessive node re- generation. In the example in Figure 3.27, RBFS first follows the path via Rimnicu Vilcea, then “changes its mind” and tries Fagaras, and then changes its mind back again. These mind changes occur because every time the current best path is extended, there is a good chance 
AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE 
DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
Section 3.5. Informed (Heuristic) Search Strategies 101 
that its f-value will increase—h is usually less optimistic for nodes closer to the goal. When this happens, particularly in large search spaces, the second-best path might become the best path, so the search has to backtrack to follow it. Each mind change corresponds to an iteration of IDA∗, and could require many reexpansions of forgotten nodes to recreate the best path and extend it one more node. 
Like A∗ tree search, RBFS is an optimal algorithm if the heuristic function h(n) is admissible. Its space complexity is linear in the depth of the deepest optimal solution, but its time complexity is rather difficult to characterize: it depends both on the accuracy of the heuristic function and on how often the best path changes as nodes are expanded. 
IDA∗ and RBFS suffer from using too little memory. Between iterations, IDA∗ retains only a single number: the current f-cost limit. RBFS retains more information in memory, but it uses only linear space: even if more memory were available, RBFS has no way to make use of it. Because they forget most of that they have done, both algorithms may end up reex- panding the same states many times over. Furthermore, they suffer the potentially exponential increase in complexity associated with redundant paths in graphs (see Section 3.3). 
It seems sensible, therefore, to use all available memory. Two algorithms that do this are MA∗ (memory-bounded A∗) and SMA∗ (simplified MA∗). We will describe SMA∗, which MA* SMA* is—well—simpler. SMA∗ proceeds just like A∗, expanding the best leaf until memory is full. At this point, it cannot add a new node to the search tree without dropping an old one. SMA∗ always drops the worst leaf node—the one with the highest f-value. Like RBFS, SMA∗ then backs up the value of the forgotten node to its parent. In this way, the ancestor of a forgotten subtree knows the quality of the best path in that subtree. With this information, SMA∗ regenerates the subtree only when all other paths have been shown to look worse than 
AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE 
function RECURSIVE-BEST-FIRST-SEARCH(problem) returns a solution, or failure 
return RBFS(problem,MAKE-NODE(problem.INITIAL-STATE),∞) 
function RBFS(problem,node,f 
limit) returns a solution, or failure and a new f-cost limit if problem.GOAL-TEST(node.STATE) then return SOLUTION(node) successors ←[] for each action in problem.ACTIONS(node.STATE) do 
add CHILD-NODE(problem,node,action) into successors if successors is empty then return failure, ∞ for each s in successors do /* update f with value from previous search, if any */ 
s.f ←max(s.g + s.h, node.f )) loop do 
best ←the lowest f-value node in successors if best.f > f 
Figure 3.26 The algorithm for recursive best-first search. 
limit then return failure, best.f alternative ←the second-lowest f-value among successors result,best.f ←RBFS(problem,best,min(f 
limit,alternative)) if result = failure then return result 
Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
102 Chapter 3. Solving Problems by Searching 
DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
the path it has forgotten. Another way of saying this is that, if all the descendants of a node n are forgotten, then we will not know which way to go from n, but we will still have an idea of how worthwhile it is to go anywhere from n. 
AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE 
Figure 3.27 Stages in an RBFS search for the shortest route to Bucharest. The f-limit value for each recursive call is shown on top of each current node, and every node is labeled with its f-cost. (a) The path via Rimnicu Vilcea is followed until the current best leaf (Pitesti) has a value that is worse than the best alternative path (Fagaras). (b) The recursion unwinds and the best leaf value of the forgotten subtree (417) is backed up to Rimnicu Vilcea; then Fagaras is expanded, revealing a best leaf value of 450. (c) The recursion unwinds and the best leaf value of the forgotten subtree (450) is backed up to Fagaras; then Rimnicu Vilcea is expanded. This time, because the best alternative path (through Timisoara) costs at least 447, the expansion continues to Bucharest. 
(a) After expanding Arad, Sibiu, 
and Rimnicu Vilcea 
(b) (c) After and expanding switching Pitesti 
back to Rimnicu Vilcea ∞ Arad 366 
447 Sibiu 
393 
Timisoara 
447 Zerind 
449 415 Arad 
646 Fagaras 415 Oradea 671 
Rimnicu Vilcea 
413 
Craiova Pitesti 526 417 
After unwinding back to Sibiu ∞ and expanding Fagaras 
366 
393 
∞ 
447 
Timisoara 
447 
447417 
Sibiu 
553 
Arad 
447 Sibiu 
Timisoara 
447 
Zerind 
449 
417 Arad 
Fagaras 646 415 
Oradea 
671 Rimnicu Vilcea 413 417 Sibiu Bucharest 
591 
450 Arad 
366 
Sibiu 
393 
447 Zerind 
449 
Arad 646 Fagaras 415 450 Oradea 
671 
Rimnicu Vilcea 417 Craiova Pitesti 
Sibiu 526 553 
Bucharest Craiova Rimnicu Vilcea 
418 615 607 
Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
Section 3.5. Informed (Heuristic) Search Strategies 103 
The complete algorithm is too complicated to reproduce here,8 but there is one subtlety worth mentioning. We said that SMA∗ expands the best leaf and deletes the worst leaf. What if all the leaf nodes have the same f-value? To avoid selecting the same node for deletion and expansion, SMA∗ expands the newest best leaf and deletes the oldest worst leaf. These coincide when there is only one leaf, but in that case, the current search tree must be a single path from root to leaf that fills all of memory. If the leaf is not a goal node, then even if it is on an optimal solution path, that solution is not reachable with the available memory. Therefore, the node can be discarded exactly as if it had no successors. 
SMA∗ is complete if there is any reachable solution—that is, if d, the depth of the shallowest goal node, is less than the memory size (expressed in nodes). It is optimal if any optimal solution is reachable; otherwise it returns the best reachable solution. In practical terms, SMA∗ is a fairly robust choice for finding optimal solutions, particularly when the state space is a graph, step costs are not uniform, and node generation is expensive compared to the overhead of maintaining the frontier and explored set. 
On very hard problems, however, it will often be the case that SMA∗ is forced to switch back and forth continually among many candidate solution paths, only a small subset of which can fit in memory. (This resembles the problem of thrashing in disk paging systems.) Then THRASHING the extra time required for repeated regeneration of the same nodes means that problems that would be practically solvable by A∗, given unlimited memory, become intractable for SMA∗. That is to say, memory limitations can make a problem intractable from the point of view of computation time. Although there is no theory to explain the tradeoff between time and memory, it seems that this is an inescapable problem. The only way out is to drop the optimality requirement. 
3.5.4 Learning to search better 
We have presented several fixed strategies—breadth-first, greedy best-first, and so on—that have been designed by computer scientists. Could an agent learn how to search better? The answer is yes, and the method rests on an important concept called the metalevel state space. METALEVEL STATE SPACE Each state in a metalevel state space captures the internal (computational) state of a program that is searching in an object-level state space such as Romania. For example, the internal OBJECT-LEVEL STATE SPACE state of the A∗ algorithm consists of the current search tree. Each action in the metalevel state space is a computation step that alters the internal state; for example, each computation step in A∗ expands a leaf node and adds its successors to the tree. Thus, Figure 3.24, which shows a sequence of larger and larger search trees, can be seen as depicting a path in the metalevel state space where each state on the path is an object-level search tree. 
Now, the path in Figure 3.24 has five steps, including one step, the expansion of Fagaras, that is not especially helpful. For harder problems, there will be many such missteps, and a metalevel learning algorithm can learn from these experiences to avoid exploring unpromis- METALEVEL LEARNING ing subtrees. The techniques used for this kind of learning are described in Chapter 21. The goal of learning is to minimize the total cost of problem solving, trading off computational expense and path cost. 
8 A rough sketch appeared in the first edition of this book. 
AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE 
Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
104 Chapter 3. Solving Problems by Searching 
3.6 HEURISTIC FUNCTIONS 
The average solution cost for a randomly generated 8-puzzle instance is about 22 steps. The branching factor is about 3. (When the empty tile is in the middle, there are four possible moves; when it is in a corner there are two; and when it is along an edge there are three.) This means that an exhaustive tree search to depth 22 would look at about 322 ≈ 3.1×1010 states. A graph search would cut this down by a factor of about 170,000, because there are only 9!/2 = 181,440 distinct states that are reachable. (See Exercise 3.17.) This is a manageable number, but the corresponding number for the 15-puzzle is roughly 1013, so the next order of business is to find a good heuristic function. If we want to find the shortest solutions by using A∗, we need a heuristic function that never overestimates the number of steps to the goal. There is a long history of such heuristics for the 15-puzzle; here are two commonly used candidates: 
• h1 = the number of misplaced tiles. For Figure 3.28, all of the eight tiles are out of position, so the start state would have h1 = 8. h1 is an admissible heuristic, because it is clear that any tile that is out of place must be moved at least once. 
• h2 = the sum of the distances of the tiles from their goal positions. Because tiles cannot move along diagonals, the distance we will count is the sum of the horizontal and vertical distances. This is sometimes called the city block distance or Manhattan MANHATTAN DISTANCE distance. h2 is also admissible, because all any move can do is move one tile one step closer to the goal. Tiles 1 to 8 in the start state give a Manhattan distance of 
h2 =3+1+2+2+2+3+3+2=18 . As expected, neither of these overestimates the true solution cost, which is 26. 
AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE 
DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
In this section, we will look at heuristics for the 8-puzzle, in order to shed light on the nature of heuristics in general. 
The 8-puzzle was one of the earliest heuristic search problems. As mentioned in Sec- tion 3.2, the object of the puzzle is to slide the tiles horizontally or vertically into the empty space until the configuration matches the goal configuration (Figure 3.28). 
Figure 3.28 A typical instance of the 8-puzzle. The solution is 26 steps long. 
4721 
2 
5 
6 
3 4 
3 4 
83 
6 7 
8 
8 
5 
5 
5 
1 
1 
1 
Start State Goal State 
Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
Section 3.6. Heuristic Functions 105 
3.6.1 The effect of heuristic accuracy on performance 
One way to characterize the quality of a heuristic is the effective branching factor b∗. If the EFFECTIVE BRANCHING FACTOR total number of nodes generated by A∗ for a particular problem is N, and the solution depth is d, then b∗ is the branching factor that a uniform tree of depth d would have to have in order to contain N + 1 nodes. Thus, 
N +1=1+ b∗ + (b∗)2 + ··· + (b∗)d . For example, if A∗ finds a solution at depth 5 using 52 nodes, then the effective branching factor is 1.92. The effective branching factor can vary across problem instances, but usually it is fairly constant for sufficiently hard problems. (The existence of an effective branching factor follows from the result, mentioned earlier, that the number of nodes expanded by A∗ grows exponentially with solution depth.) Therefore, experimental measurements of b∗ on a small set of problems can provide a good guide to the heuristic’s overall usefulness. A well- designed heuristic would have a value of b∗ close to 1, allowing fairly large problems to be solved.To test the heuristic functions h1 and h2, we generated 1200 random problems with solution lengths from 2 to 24 (100 for each even number) and solved them with iterative deepening search and with A∗ tree search using both h1 and h2. Figure 3.29 gives the average number of nodes generated by each strategy and the effective branching factor. The results suggest that h2 is better than h1, and is far better than using iterative deepening search. Even for small problems with d= 12, A∗ with h2 is 50,000 times more efficient than uninformed iterative deepening search. 
One might ask whether h2 is always better than h1. The answer is, “Essentially, yes.” It is easy to see from the definitions of the two heuristics that, for any node n, h2(n) ≥ h1(n). We thus say that h2 dominates h1. Domination translates directly into efficiency: A∗ using DOMINATION 
AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE 
10 
12 
14 
16 
18 
20 
22 
24 
d 
2 
4 
6 
8 
Figure 3.29 Comparison of the search costs and effective branching factors for the ITERATIVE-DEEPENING-SEARCH and A∗ algorithms with h1, h2. Data are averaged over 100 instances of the 8-puzzle for each of various solution lengths d. 
3644035 
47127 
IDS 
6384 
112 
680 
10 
– 
– 
– 
– 
– 
– 
A∗(h1) 
A∗(h1) 
18094 
18094 
39135 
39135 
1301 
1301 
3056 
3056 
7276 
7276 
227 
227 
539 
539 
13 
13 
20 
20 
39 
39 
93 
93 
6 
6 
A∗(h2) 
A∗(h2) 
A∗(h2) 
1219 
1219 
1219 
1641 
1641 
1641 
113 
113 
113 
211 
211 
211 
363 
363 
363 
676 
676 
676 
12 
12 
12 
18 
18 
18 
25 
25 
25 
39 
39 
39 
73 
73 
73 
6 
6 
6 
IDS 
IDS 
IDS 
IDS 
2.79 
2.79 
2.79 
2.79 
2.45 
2.45 
2.45 
2.45 
2.87 
2.87 
2.87 
2.87 
2.73 
2.73 
2.73 
2.73 
2.80 
2.80 
2.80 
2.80 
2.78 
2.78 
2.78 
2.78 
– 
– 
– 
– 
– 
– 
– 
– 
– 
– 
– 
– 
– 
– 
– 
– 
– 
– 
– 
– 
– 
– 
– 
– 
A∗(h1) 
A∗(h1) 
A∗(h1) 
A∗(h1) 
A∗(h1) 
1.79 
1.79 
1.79 
1.79 
1.79 
1.48 
1.48 
1.48 
1.48 
1.48 
1.34 
1.34 
1.34 
1.34 
1.34 
1.33 
1.33 
1.33 
1.33 
1.33 
1.38 
1.38 
1.38 
1.38 
1.38 
1.42 
1.42 
1.42 
1.42 
1.42 
1.44 
1.44 
1.44 
1.44 
1.44 
1.45 
1.45 
1.45 
1.45 
1.45 
1.46 
1.46 
1.46 
1.46 
1.46 
1.47 
1.47 
1.47 
1.47 
1.47 
1.48 
1.48 
1.48 
1.48 
1.48 
1.48 
1.48 
1.48 
1.48 
1.48 
A∗(h2) 
A∗(h2) 
A∗(h2) 
A∗(h2) 
A∗(h2) 
A∗(h2) 
1.79 
1.79 
1.79 
1.79 
1.79 
1.79 
1.45 
1.45 
1.45 
1.45 
1.45 
1.45 
1.30 
1.30 
1.30 
1.30 
1.30 
1.30 
1.24 
1.24 
1.24 
1.24 
1.24 
1.24 
1.22 
1.22 
1.22 
1.22 
1.22 
1.22 
1.24 
1.24 
1.24 
1.24 
1.24 
1.24 
1.23 
1.23 
1.23 
1.23 
1.23 
1.23 
1.25 
1.25 
1.25 
1.25 
1.25 
1.25 
1.26 
1.26 
1.26 
1.26 
1.26 
1.26 
1.27 
1.27 
1.27 
1.27 
1.27 
1.27 
1.28 
1.28 
1.28 
1.28 
1.28 
1.28 
1.26 
1.26 
1.26 
1.26 
1.26 
1.26 
Search Cost (nodes generated) 
Effective Branching Factor 
Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
106 Chapter 3. Solving Problems by Searching 
h2 will never expand more nodes than A∗ using h1 (except possibly for some nodes with f(n)=C∗). The argument is simple. Recall the observation on page 98 that every node with f(n) < C∗ will surely be expanded. This is the same as saying that every node with h(n) < C∗ − g(n) will surely be expanded. But because h2 is at least as big as h1 for all nodes, every node that is surely expanded by A∗ search with h2 will also surely be expanded with h1, and h1 might cause other nodes to be expanded as well. Hence, it is generally better to use a heuristic function with higher values, provided it does not overestimate and that the computation time for the heuristic is not too large. 
3.6.2 Generating admissible heuristics from relaxed problems 
We have seen that both h1 (misplaced tiles) and h2 (Manhattan distance) are fairly good heuristics for the 8-puzzle and that h2 is better. How might one have come up with h2? Is it possible for a computer to invent such a heuristic mechanically? 
h1 and h2 are estimates of the remaining path length for the 8-puzzle, but they are also perfectly accurate path lengths for simplified versions of the puzzle. If the rules of the puzzle were changed so that a tile could move anywhere, instead of just to the adjacent empty square, then h1 would give the exact number of steps in the shortest solution. Similarly, if a tile could move one square in any direction, even onto an occupied square, then h2 would give the exact number of steps in the shortest solution. A problem with fewer restrictions on the actions is 
RELAXED PROBLEM 
called a relaxed problem. The state-space graph of the relaxed problem is a supergraph of the original state space, because the removal of restrictions creates added edges in the graph. Because the relaxed problem adds edges to the state space, any optimal solution in the original problem is, by definition, also a solution in the relaxed problem; but the relaxed problem may have better solutions if the added edges provide short cuts. Hence, the cost of an optimal solution to a relaxed problem is an admissible heuristic for the original problem. Furthermore, because the derived heuristic is an exact cost for the relaxed problem, it must obey the triangle inequality and is therefore consistent (see page 96). 
If a problem definition is written down in a formal language, it is possible to construct relaxed problems automatically.9 For example, if the 8-puzzle actions are described as 
A tile can move from square A to square B if 
A is horizontally or vertically adjacent to B and B is blank, we can generate three relaxed problems by removing one or both of the conditions: 
(a) A tile can move from square A to square B if A is adjacent to B. (b) A tile can move from square A to square B if B is blank. (c) A tile can move from square A to square B. 
From (a), we can derive h2 (Manhattan distance). The reasoning is that h2 would be the proper score if we moved each tile in turn to its destination. The heuristic derived from (b) is discussed in Exercise 3.39. From (c), we can derive h1 (misplaced tiles), because it would be the proper score if tiles could move to their intended destination in one step. Notice that it is 
DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
9 In Chapters 8 and 11, we will describe formal languages suitable for this task; with formal descriptions that can be manipulated, the construction of relaxed problems can be automated. For now, we will use English. 
AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE 
Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
Section 3.6. Heuristic Functions 107 
crucial that the relaxed problems generated by this technique can be solved essentially without search, because the relaxed rules allow the problem to be decomposed into eight independent subproblems. If the relaxed problem is hard to solve, then the values of the corresponding heuristic will be expensive to obtain.10 
A program called ABSOLVER can generate heuristics automatically from problem def- initions, using the “relaxed problem” method and various other techniques (Prieditis, 1993). ABSOLVER generated a new heuristic for the 8-puzzle that was better than any preexisting heuristic and found the first useful heuristic for the famous Rubik’s cube puzzle. 
One problem with generating new heuristic functions is that one often fails to get one “clearly best” heuristic. If a collection of admissible heuristics h1 ...hm is available for a problem, and none of them dominates any of the others, which should we choose? As it turns out, we need not make a choice. We can have the best of all worlds, by defining 
h(n) = max{h1(n),...,hm(n)} . This composite heuristic uses whichever function is most accurate on the node in question. Because the component heuristics are admissible, h is admissible; it is also easy to prove that h is consistent. Furthermore, h dominates all of its component heuristics. 
3.6.3 Generating admissible heuristics from subproblems: Pattern databases 
Admissible heuristics can also be derived from the solution cost of a subproblem of a given SUBPROBLEM problem. For example, Figure 3.30 shows a subproblem of the 8-puzzle instance in Fig- ure 3.28. The subproblem involves getting tiles 1, 2, 3, 4 into their correct positions. Clearly, the cost of the optimal solution of this subproblem is a lower bound on the cost of the com- plete problem. It turns out to be substantially more accurate than Manhattan distance in some cases.The idea behind pattern databases is to store these exact solution costs for every pos- PATTERN DATABASES sible subproblem instance—in our example, every possible configuration of the four tiles and the blank. (Notice that the locations of the other four tiles are irrelevant for the purposes of 
10 Note that a perfect heuristic can be obtained simply by allowing h to run a full breadth-first search “on the sly.” Thus, there is a tradeoff between accuracy and computation time for heuristic functions. 
AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE 
Figure 3.30 A subproblem of the 8-puzzle instance given in Figure 3.28. The task is to get tiles 1, 2, 3, and 4 into their correct positions, without worrying about what happens to the other tiles. 
23 45 6 
8
21 
3 6 7 854 
1 
Start State Goal State 
Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
108 Chapter 3. Solving Problems by Searching 
solving the subproblem, but moves of those tiles do count towards the cost.) Then we com- pute an admissible heuristic hDB for each complete state encountered during a search simply by looking up the corresponding subproblem configuration in the database. The database itself is constructed by searching backward11 from the goal state and recording the cost of each new pattern encountered; the expense of this search is amortized over many subsequent problem instances. 
The choice of 1-2-3-4 is fairly arbitrary; we could also construct databases for 5-6-7-8, for 2-4-6-8, and so on. Each database yields an admissible heuristic, and these heuristics can be combined, as explained earlier, by taking the maximum value. A combined heuristic of this kind is much more accurate than the Manhattan distance; the number of nodes generated when solving random 15-puzzles can be reduced by a factor of 1000. 
One might wonder whether the heuristics obtained from the 1-2-3-4 database and the 5-6-7-8 could be added, since the two subproblems seem not to overlap. Would this still give an admissible heuristic? The answer is no, because the solutions of the 1-2-3-4 subproblem and the 5-6-7-8 subproblem for a given state will almost certainly share some moves—it is unlikely that 1-2-3-4 can be moved into place without touching 5-6-7-8, and vice versa. But what if we don’t count those moves? That is, we record not the total cost of solving the 1-2-3-4 subproblem, but just the number of moves involving 1-2-3-4. Then it is easy to see that the sum of the two costs is still a lower bound on the cost of solving the entire problem. DISJOINT PATTERN DATABASES This is the idea behind disjoint pattern databases. Using such databases, it is possible to solve random 15-puzzles in a few milliseconds—the number of nodes generated is reduced by a factor of 10,000 compared with using Manhattan distance. For 24-puzzles, a speedup of roughly a million can be obtained. 
Disjoint pattern databases work for sliding-tile puzzles because the problem can be divided up in such a way that each move affects only one subproblem—because only one tile is moved at a time. For a problem such as Rubik’s cube, this kind of subdivision cannot be done because each move affects 8 or 9 of the 26 cubies. Currently, it is not clear how to define disjoint databases for such problems. 
3.6.4 Learning heuristics from experience 
A heuristic function h(n) is supposed to estimate the cost of a solution beginning from the state at node n. How could an agent construct such a function? One solution was given in the preceding sections—namely, to devise relaxed problems for which an optimal solution can be found easily. Another solution is to learn from experience. “Experience” here means solving lots of 8-puzzles, for instance. Each optimal solution to an 8-puzzle problem provides examples from which h(n) can be learned. Each example consists of a state from the solu- tion path and the actual cost of the solution from that point. From these examples, a learning algorithm can be used to construct a function h(n) that can (with luck) predict solution costs for other states that arise during search. Techniques for doing just this using neural nets, de- 
DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
11 By working backward from the goal, the exact solution cost of every instance encountered is immediately available with no further computation. This is an example of dynamic programming, which we discuss further in Chapter 17. 
AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE 
Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
Section 3.7. Summary 109 
cision trees, and other methods are demonstrated in Chapter 18. (The reinforcement learning methods described in Chapter 21 are also applicable.) Inductive learning methods work best when supplied with features of a state that are FEATURES relevant to predicting the state’s value, rather than with just the raw state description. For example, the feature “number of misplaced tiles” might be helpful in predicting the actual distance of a state from the goal. Let’s call this feature x1(n). We could take 100 randomly generated 8-puzzle configurations and gather statistics on their actual solution costs. We might find that when x1(n) is 5, the average solution cost is around 14, and so on. Given these data, the value of x1 can be used to predict h(n). Of course, we can use several features. A second feature x2(n) might be “number of pairs of adjacent tiles that are not adjacent in the goal state.” How should x1(n) and x2(n) be combined to predict h(n)? A common approach is to use a linear combination: 
h(n) = c1x1(n) + c2x2(n) . The constants c1 and c2 are adjusted to give the best fit to the actual data on solution costs. One expects both c1 and c2 to be positive, because misplaced tiles and incorrect adjacent pairs make the problem harder to solve. Notice that this heuristic does satisfy the condition that h(n)=0 for goal states, but it is not necessarily admissible or consistent. 
3.7 SUMMARY 
This chapter has introduced methods that an agent can use to select actions in environments that are deterministic, observable, static, and completely known. In such cases, the agent can construct sequences of actions that achieve its goals; this process is called search. 
• Before an agent can start searching for solutions, a goal must be identified and a well- defined problem must be formulated. 
• A problem consists of five parts: the initial state, a set of actions, a transition model describing the results of those actions, a goal test function, and a path cost function. The environment of the problem is represented by a state space. A path through the state space from the initial state to a goal state is a solution. 
• Search algorithms treat states and actions as atomic: they do not consider any internal structure they might possess. 
• A general TREE-SEARCH algorithm considers all possible paths to find a solution, while a GRAPH-SEARCH algorithm avoids consideration of redundant paths. 
• Search algorithms are judged on the basis of completeness, optimality, time complex- ity, and space complexity. Complexity depends on b, the branching factor in the state space, and d, the depth of the shallowest solution. 
• Uninformed search methods have access only to the problem definition. The basic algorithms are as follows: 
– Breadth-first search expands the shallowest nodes first; it is complete, optimal 
for unit step costs, but has exponential space complexity. 
AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE 
Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
110 Chapter 3. Solving Problems by Searching 
– Uniform-cost search expands the node with lowest path cost, g(n), and is optimal 
for general step costs. – Depth-first search expands the deepest unexpanded node first. It is neither com- plete nor optimal, but has linear space complexity. Depth-limited search adds a depth bound. – Iterative deepening search calls depth-first search with increasing depth limits until a goal is found. It is complete, optimal for unit step costs, has time complexity comparable to breadth-first search, and has linear space complexity. – Bidirectional search can enormously reduce time complexity, but it is not always 
applicable and may require too much space. 
• Informed search methods may have access to a heuristic function h(n) that estimates the cost of a solution from n. 
– The generic best-first search algorithm selects a node for expansion according to 
an evaluation function. – Greedy best-first search expands nodes with minimal h(n). It is not optimal, but 
is often efficient. – A∗ search expands nodes with minimal f(n) = g(n) + h(n). A∗ is complete and optimal, provided that h(n) is admissible (for TREE-SEARCH) or consistent (for GRAPH-SEARCH). The space complexity of A∗ is still prohibitive. – RBFS (recursive best-first search) and SMA∗ (simplified memory-bounded A∗) are robust, optimal search algorithms that use limited amounts of memory; given enough time, they can solve problems that A∗ cannot solve because it runs out of memory. 
• The performance of heuristic search algorithms depends on the quality of the heuristic function. Good heuristics can sometimes be constructed by relaxing the problem defi- nition, by storing precomputed solution costs for subproblems in a pattern database, or by learning from experience with the problem class. 
BIBLIOGRAPHICAL AND HISTORICAL NOTES 
The topic of state-space search originated in more or less its current form in the early years of AI. Newell and Simon’s work on the Logic Theorist (1957) and GPS (1961) led to the estab- lishment of search algorithms as the primary weapons in the armory of 1960s AI researchers and to the establishment of problem solving as the canonical AI task. Work in operations research by Richard Bellman (1957) showed the importance of additive path costs in sim- plifying optimization algorithms. The text on Automated Problem Solving by Nils Nilsson (1971) established the area on a solid theoretical footing. 
Most of the state-space search problems analyzed in this chapter have a long history in the literature and are less trivial than they might seem. The missionaries and cannibals problem used in Exercise 3.22 was analyzed in detail by Amarel (1968). It had been consid- 
AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE 
DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
Section 3.7. Summary 111 
ered earlier in AI by Simon and Newell (1961), and in operations research by Bellman and Dreyfus (1962). 
The 8-puzzle is a smaller cousin of the 15-puzzle, whose history is recounted at length by Slocum and Sonneveld (2006). For most of the 20th century, it was widely believed to have been invented by the famous American game designer Sam Loyd, based on his claims to that effect from 1891 onwards (Loyd, 1959). It turns out to have been invented by Noyes Chapman, a postmaster in Canastota, New York, in the mid-1870s, and achieved immense popularity in the United States and Europe. (Chapman was unable to patent his invention, as a generic patent covering sliding blocks with letters, numbers, or pictures was granted to Ernest Kinsey in 1878.) It also quickly attracted the attention of mathematicians (Johnson and Story, 1879; Tait, 1880). The editors of the American Journal of Mathematics stated, “The ‘15’ puzzle for the last few weeks has been prominently before the American public, and may safely be said to have engaged the attention of nine out of ten persons of both sexes and all ages and conditions of the community. But this would not have weighed with the editors to induce them to insert articles upon such a subject in the American Journal of Mathematics, but for the fact that ...” (there follows a summary of the mathematical interest of the 15-puzzle). An exhaustive analysis of the 8-puzzle was carried out with computer aid by Schofield (1967). Ratner and Warmuth (1986) showed that the general n × n version of the 15-puzzle belongs to the class of NP-complete problems. 
The 8-queens problem was first published anonymously in the German chess maga- zine Schach in 1848; it was later attributed to one Max Bezzel. It was republished in 1850 and at that time drew the attention of the eminent mathematician Carl Friedrich Gauss, who attempted to enumerate all possible solutions, but found only 72. Nauck published all 92 solutions later in 1850. Netto (1901) generalized the problem to n queens, and Abramson and Yung (1989) found an O(n) algorithm. 
Each of the real-world search problems listed in the chapter has been the subject of a good deal of research effort. Methods for selecting optimal airline flights remain propri- etary for the most part, but Carl de Marcken (personal communication) has shown that airline ticket pricing and restrictions have become so convoluted that the problem of selecting an optimal flight is formally undecidable. The traveling-salesperson problem is a standard com- binatorial problem in theoretical computer science (Lawler, 1985; Lawler et al., 1992). Karp (1972) proved the TSP to be NP-hard, but effective heuristic approximation methods were de- veloped (Lin and Kernighan, 1973). Arora (1998) devised a fully polynomial approximation scheme for Euclidean TSPs. VLSI layout methods are surveyed by Shahookar and Mazumder (1991), and many layout optimization papers appear in VLSI journals. Robotic navigation and assembly problems are discussed in Chapter 25. 
Uninformed search algorithms for problem solving are a central topic of classical com- puter science (Horowitz and Sahni, 1978) and operations research (Dreyfus, 1969). Breadth- first search was formulated for solving mazes by Moore (1959). The method of dynamic programming (Bellman, 1957; Bellman and Dreyfus, 1962), which systematically records solutions for all subproblems of increasing lengths, can be seen as a form of breadth-first search on graphs. The two-point shortest-path algorithm of Dijkstra (1959) is the origin of uniform-cost search. These works also introduced the idea of explored and frontier sets 
AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE 
Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
112 Chapter 3. Solving Problems by Searching 
(closed and open lists). 
A version of iterative deepening designed to make efficient use of the chess clock was first used by Slate and Atkin (1977) in the CHESS 4.5 game-playing program, but the appli- cation to shortest-path graph search is due to Korf (1985a). Bidirectional search, which was introduced by Pohl (1969, 1971), can also be very effective in some cases. 
The use of heuristic information in problem solving appears in an early paper by Simon and Newell (1958), but the phrase “heuristic search” and the use of heuristic functions that estimate the distance to the goal came somewhat later (Newell and Ernst, 1965; Lin, 1965). Doran and Michie (1966) conducted extensive experimental studies of heuristic search as applied to a number of problems, especially the 8-puzzle and the 15-puzzle. Although Doran and Michie carried out theoretical analyses of path length and “penetrance” (the ratio of path length to the total number of nodes examined so far) in heuristic search, they appear to have ignored the information provided by the path cost g(n). The A∗ algorithm, incorporating the current path cost into heuristic search, was developed by Hart, Nilsson, and Raphael (1968), with some later corrections (Hart et al., 1972). Dechter and Pearl (1985) demonstrated the optimal efficiency of A∗. 
The original A∗ paper introduced the consistency condition on heuristic functions. The monotone condition was introduced by Pohl (1977) as a simpler replacement, but Pearl (1984) showed that the two were equivalent. 
Pohl (1970, 1977) pioneered the study of the relationship between the error in heuristic functions and the time complexity of A∗. Basic results were obtained for tree search with unit step costs and a single goal node (Pohl, 1977; Gaschnig, 1979; Huyn et al., 1980; Pearl, 1984) and with multiple goal nodes (Dinh et al., 2007). The “effective branching factor” was proposed by Nilsson (1971) as an empirical measure of the efficiency; it is equivalent to assuming a time cost of O((b∗)d). For tree search applied to a graph, Korf et al. (2001) argue that the time cost is better modelled as O(bd−k) where k depends on the heuristic accuracy; this analysis has elicited some controversy, however. For graph search, Helmert and R ̈oger (2008) noted that several well-known problems contained exponentially many nodes on optimal solution paths, implying exponential time complexity for A∗ even with constant absolute error in h. 
There are many variations on the A∗ algorithm. Pohl (1973) proposed the use of dynamic weighting, which uses a weighted sum fw(n)=wgg(n) + whh(n) of the current path length and the heuristic function as an evaluation function, rather than the simple sum f(n)=g(n)+ h(n) used in A∗. The weights wg and wh are adjusted dynamically as the search progresses. Pohl’s algorithm can be shown to be ǫ-admissible—that is, guaranteed to find solutions within a factor 1 + ǫ of the optimal solution—where ǫ is a parameter supplied to the algorithm. The same property is exhibited by the A∗ǫ algorithm (Pearl, 1984), which can select any node from the frontier provided its f-cost is within a factor 1+ǫ of the lowest-f-cost frontier node. The selection can be done so as to minimize search cost. 
Bidirectional versions of A∗ have been investigated (de Champeaux and Sint, 1977; de Champeaux, 1983), but their algorithmic intricacy has not been compensated for by signifi- cant performance improvements over A∗. A more promising approach seems to be to run a breadth-first search backward from the goal up to a fixed depth, followed by a forward IDA* 
AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE 
DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
Section 3.7. Summary 113 
search (Dillenburg and Nelson, 1994; Manzini, 1995). 
A∗ and other state-space search algorithms are closely related to the branch-and-bound techniques that are widely used in operations research (Lawler and Wood, 1966). The relationships between state-space search and branch-and-bound have been investigated in depth (Kumar and Kanal, 1983; Nau et al., 1984; Kumar et al., 1988). Martelli and Monta- nari (1978) demonstrate a connection between dynamic programming (see Chapter 17) and certain types of state-space search. Kumar and Kanal (1988) attempt a “grand unification” of heuristic search, dynamic programming, and branch-and-bound techniques under the name of CDP—the “composite decision process.” 
Because computers in the late 1950s and early 1960s had at most a few thousand words of main memory, memory-bounded heuristic search was an early research topic. The Graph Traverser (Doran and Michie, 1966), one of the earliest search programs, commits to an operator after searching best first up to the memory limit. IDA∗ (Korf, 1985a, 1985b) was the first widely used optimal, memory-bounded, heuristic search algorithm, and a large number of variants have been developed. An analysis of the efficiency of IDA∗ and of its difficulties with real-valued heuristics appears in Patrick et al. (1992). 
RBFS (Korf, 1991, 1993) is actually somewhat more complicated than the algorithm shown in Figure 3.26, which is closer to an independently developed algorithm called itera- tive expansion, or IE (Russell, 1992). RBFS uses a lower bound as well as the upper bound; ITERATIVE EXPANSION the two algorithms behave identically with admissible heuristics, but RBFS expands nodes in best-first order even with an inadmissible heuristic. The idea of keeping track of the best alternative path appeared earlier in Bratko’s (1986) elegant Prolog implementation of A∗ and in the DTA∗ algorithm (Russell and Wefald, 1991). The latter work also discusses metalevel state spaces and metalevel learning. 
The MA∗ algorithm appeared in Chakrabarti et al. (1989). SMA∗, or Simplified MA∗, emerged from an attempt to implement MA∗ as a comparison algorithm for IE (Russell, 1992). Kaindl and Khorsand (1994) have applied SMA∗ to produce a bidirectional search algorithm that is substantially faster than previous algorithms. Korf and Zhang (2000) describe a divide- and-conquer approach, and Zhou and Hansen (2002) introduce memory-bounded A∗ graph search. Korf (1995) surveys memory-bounded search techniques. 
The idea that admissible heuristics can be derived by problem relaxation appears in the seminal paper by Held and Karp (1970), who used the minimum-spanning-tree heuristic to solve the TSP. (See Exercise 3.38.) 
The automation of the relaxation process was implemented successfully by Priedi- tis (1993), building on earlier work with Mostow (Mostow and Prieditis, 1989). The use of pattern databases to derive admissible heuristics is due to Gasser (1995) and Culberson and Schaeffer (1998); disjoint pattern databases are described by Korf and Felner (2002). The probabilistic interpretation of heuristics was investigated in depth by Pearl (1984) and Hansson and Mayer (1989). 
By far the most comprehensive source on heuristics and heuristic search algorithms is Pearl’s (1984) Heuristics text. This book provides especially good coverage of the wide va- riety of offshoots and variations of A∗, including rigorous proofs of their formal properties. The textbooks by Nilsson (1971, 1980) are good general sources of information about clas- 
AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE 
Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
114 Chapter 3. Solving Problems by Searching 
sical search algorithms. Kanal and Kumar (1988) present an anthology of important articles on heuristic search. Papers about new search algorithms—which, remarkably, continue to be discovered—appear in journals such as Artificial Intelligence and Journal of the ACM. 
PARALLEL SEARCH 
The topic of parallel search algorithms was not covered in the chapter, partly because it requires a lengthy discussion of parallel computer architectures. Parallel search became a popular topic in the 1990s in both AI and theoretical computer science (Mahanti and Daniels, 1993; Grama and Kumar, 1995; Crauser et al., 1998) and is making a comeback in the era of new multicore and cluster architectures (Ralphs et al., 2004; Korf and Schultze, 2005). Also of increasing importance are search algorithms for very large graphs that require disk storage (Korf, 2008). 
EXERCISES 
3.1 Define in your own words the following terms: state, state space, search tree, search node, goal, action, transition model, and branching factor. 
3.2 Explain why problem formulation must follow goal formulation. 
3.3 Which of the following are true and which are false? Give a brief explanation for each answer. 
a. Depth-first search always expands at least as many nodes as A∗ search with an admissi- 
ble heuristic. b. h(n)=0 is an admissible heuristic for the 8-puzzle. c. A∗ search cannot be used in robotics because percepts, states, and actions are continu- 
ous. d. Breadth-first search is complete even if zero step-costs are allowed. e. Assume that a rook can move on a chessboard any number of squares in a straight line, vertically or horizontally, but cannot jump over other pieces. Manhattan distance is an admissible heuristic for the problem of moving the rook from square A to square B in the smallest number of moves. 
3.4 Give a complete problem formulation for each of the following problems. Choose a formulation that is precise enough to be implemented. 
a. There are six glass boxes in a row, each with a lock. Each of the first five boxes holds a key unlocking the next box in line, the last holds a banana. You have the key to the first box, and you want the banana. b. You start with the sequence ABABAECCEC, or in general any sequence made from A, B, C, and E. You can transform this sequence using the following equalities: AC = E, AB = BC, BB = E, and Ex = x for any x. For example, ABBC can be transformed into AEC, and then AC, and then E. Your goal is to produce the sequence E. c. There is an n by n grid of squares, each square initially being either unpainted floor or a bottomless pit. You start standing on an unpainted floor square, and can either paint 
AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE 
DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
Section 3.7. Summary 115 
the square under you, or move onto an adjacent unpainted floor square. You want the whole floor painted. d. A container ship is in port, loaded high with containers. There 13 rows of containers, each 13 containers wide and 5 containers tall. You control a crane that can move to any location above the ship, pick up the container under it, and move it onto the dock. You want the ship unloaded. 
3.5 Your goal is to navigate a robot out of a maze. The robot starts in the center of the maze facing north. You can turn the robot to face north, east, south, or west. You can direct the robot to move forward a certain distance, although it will stop before hitting a wall. 
a. Formulate this problem. How large is the state space? b. In navigating a maze, the only place we need to turn is at the intersection of two or more corridors. Reformulate this problem using this observation. How large is the state space now? c. From each point in the maze, we can move in any of the four directions until we reach a turning point, and this is the only action we need to do. Reformulate the problem using these actions. Do we need to keep track of the robot’s orientation now? d. In our initial description of the problem we already abstracted from the real world, restricting actions and removing irrelevant details. List three such simplifications we made. 
3.6 What’s the difference between a world state, a state description, and a search node? Why is this distinction useful? 
3.7 You have a 9× 9 grid of squares, each of which can be colored red or blue. The grid is initially colored all blue, but you can change the color of any square any number of times. Imagining the grid divided into nine 3×3 sub-squares, you want each sub-square to be all one color, but neighboring sub-squares to be different colors. 
a. Formulate this problem in the straightforward way. Compute the size of the state space. b. You need color a square only once. Reformulate, and compute the size of the state space. Would breadth-first graph search perform faster on this problem than on the one in (a)? How about iterative-deepening tree search? c. Given the goal, we need consider only colorings where each sub-square is uniformly 
colored. Reformulate the problem and compute the size of the state space. d. How many solutions does this problem have? e. Parts (b) and (c) successively abstracted the original problem (a). Can you give a trans- lation from solutions in problem (c) into solutions in problem (b), and from solutions in problem (b) into solutions for problem (a)? 
3.8 An action such as Go(Sibiu) really consists of a long sequence of finer-grained actions: turn on the car, release the brake, accelerate forward, etc. Having composite actions of this kind reduces the number of steps in a solution sequence, thereby reducing the search time. 
AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE 
Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
116 Chapter 3. Solving Problems by Searching 
Suppose we take this to the logical extreme, by making super-composite actions out of every possible sequence of Go actions. Then every problem instance is solved by a single super- composite action, such as Go(Sibiu)Go(Rimnicu Vilcea)Go(Pitesti)Go(Bucharest). Explain how search would work in this formulation. Is this a practical approach for speeding up problem solving? 
3.9 Consider a state space where the start state is number 1 and each state k has two suc- cessors, numbers 2k and 2k + 1. 
a. Draw the portion of the state space for states 1 to 15. b. Suppose the goal state is 11. List the order in which nodes will be visited for breadth- 
first search, depth-limited search with limit 3, and iterative deepening search. c. How well would bidirectional search work on this problem? What is the branching 
factor in each direction of the bidirectional search? d. Does the answer to (c) suggest a reformulation of the problem that would allow you to 
solve the problem of getting from state 1 to a given goal state with almost no search? e. Call the action going from k to 2k Left, and the action going to 2k + 1 Right. Can you 
find an algorithm to output the solution to this problem without any search at all? 
3.10 Accurate heuristics don’t necessarily reduce search time, in the worst case. Given any depth d, define a search problem with a goal node at depth d, and a heuristic function such that |h(n) − h∗(n)| ≤ O(logh∗(n)) but A∗ expands all nodes of depth less than d. 
HEURISTIC PATH ALGORITHM 3.11 The heuristic path algorithm (Pohl, 1977) is a best-first search in which the evalu- ation function is f(n) = (2 − w)g(n) + wh(n). For what values of w is this complete? For what values is it optimal, assuming that h is admissible? What kind of search does this perform for w = 0, w = 1, and w = 2? 
3.12 Consider the unbounded version of the regular 2D grid shown in Figure 3.9. The start state is at the origin, (0,0), and the goal state is at (x, y). 
a. What is the branching factor b in this state space? b. How many distinct states are there at depth k (for k > 0)? c. What is the maximum number of nodes expanded by breadth-first search tree search? d. What is the maximum number of nodes expanded by breadth-first search graph search? e. Is h = |u − x| + |v − y| an admissible heuristic for a state at (u, v)? Explain. f. How many nodes are expanded by A∗ graph search using h? g. Does h remain admissible if some links are removed? h. Does h remain admissible if some links are added between nonadjacent states? 
3.13 n vehicles occupy squares (1,1) through (n,1) (i.e., the bottom row) of an n×n grid. The vehicles must be moved to the top row but in reverse order; so the vehicle i that starts in (i,1) must end up in (n − i+1,n). On each time step, every one of the n vehicles can move one square up, down, left, or right, or stay put; but if a vehicle stays put, one other adjacent vehicle (but not more than one) can hop over it. Two vehicles cannot occupy the same square. 
AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE 
DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
Section 3.7. Summary 117 
a. Calculate the size of the state space as a function of n. b. Calculate the branching factor as a function of n. c. Suppose that vehicle i is at (xi,yi); write a nontrivial admissible heuristic hi for the number of moves it will require to get to its goal location (n−i+1,n), assuming there are no other vehicles on the grid. d. Which of the following heuristics are admissible for the problem of moving all n vehi- 
cles to their destinations? Explain. 
(i) ∑ni =1 hi. (ii) max{h1,...,hn}. (iii) min{h1,...,hn}. 
3.14 A basic wooden railway set contains the pieces shown in Figure 3.31. The task is to connect these pieces into a railway that has no loose ends where a train could run off onto the floor and no overlapping tracks. 
a. Suppose that the pieces fit together exactly with no slack. Give a precise formulation of 
the task as a search problem. b. Identify a suitable uninformed search algorithm for this task and explain your choice. c. Explain briefly why removing any one of the “fork” pieces makes the problem unsolv- 
able. d. Give an upper bound on the total size of the state space defined by your formulation. (Hint: think about the maximum branching factor for the construction process and the maximum depth, ignoring the problem of overlapping pieces and loose ends. Begin by pretending that every piece is unique.) 
3.15 Consider the problem of moving k knights from k starting squares s1,...,sk to k goal squares g1,...,gk, on an unbounded chessboard, subject to the rule that no two knights can land on the same square at the same time. Each action consists of moving up to k knights simultaneously. We would like to complete the maneuver in the smallest number of actions. 
a. What is the maximum branching factor in this state space, expressed as a function of k? 
AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE 
Figure 3.31 The track pieces in a wooden railway set; each is labeled with the number of copies in the set. Note that curved pieces and “fork” pieces (“switches” or “points”) can be flipped over, so they can curve in either direction. Each curve subtends 45 degrees. 
x 12 
x 16 
x 2 x 2 
Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
118 Chapter 3. Solving Problems by Searching 
b. Suppose hi is an admissible heuristic for the problem of moving knight i to goal gi by itself. Which of the following heuristics are admissible for the k-knight problem? Of those, which is the best? (i) min{h1,...,hk}. (ii) (iii) DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
max{h∑ki =1 h1,...,hi. 
k}. 
3.16 Suppose there are two friends living in different cities on a map, such as the Romania map shown in Figure 3.2. On every turn, we can move each friend simultaneously to a neighboring city on the map. The amount of time needed to move from city i to neighbor j is equal to the road distance d(i, j) between the cities, but on each turn the friend that arrives first must wait until the other one arrives (and calls the first on his/her cell phone) before the next turn can begin. We want the two friends to meet as quickly as possible. 
a. Write a detailed formulation for this search problem. (You will find it helpful to define 
some formal notation here.) b. Let D(i, j) be the straight-line distance between any two cities i and j. Which, if any, of the following heuristic functions are admissible? (i) D(i, j); (ii) 2 · D(i, j); (iii) D(i, j)/2. c. Are there completely connected maps for which no solution exists? d. Are there maps in which all solutions require one friend to visit the same city twice? 
3.17 Show that the 8-puzzle states are divided into two disjoint sets, such that any state is reachable from any other state in the same set, while no state is reachable from any state in the other set. (Hint: See Berlekamp et al. (1982).) Devise a procedure that will tell you which set a given state is in, and explain why this is a good thing to have for generating random states. 
3.18 page 74. Consider Explain the why n-queens the state problem space size using is at the least “efficient” √ 
3n! and incremental estimate the formulation largest n for given which on 
exhaustive exploration is feasible. (Hint: Derive a lower bound on the branching factor by considering the maximum number of squares that a queen can attack in any column.) 
3.19 Does a finite state space always lead to a finite search tree? How about a finite state space that is a tree? Can you be more precise about what types of state spaces always lead to finite search trees? (Adapted from Bender, 1996.) 
3.20 Prove that GRAPH-SEARCH satisfies the graph separation property illustrated in Fig- ure 3.9. (Hint: Begin by showing that the property holds at the start, then show that if it holds before an iteration of the algorithm, it holds afterwards.) Describe a search algorithm that violates the property. 
3.21 Give a complete problem formulation for each of the following. Choose a formulation that is precise enough to be implemented. 
a. You have to color a planar map using only four colors, in such a way that no two 
adjacent regions have the same color. 
AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE 
Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
Section 3.7. Summary 119 
b. A 3-foot-tall monkey is in a room where some bananas are suspended from the 8-foot ceiling. He would like to get the bananas. The room contains two stackable, movable, climbable 3-foot-high crates. c. You have a program that outputs the message “illegal input record” when fed a certain file of input records. You know that processing of each record is independent of the other records. You want to discover what record is illegal. d. You have three jugs, measuring 12 gallons, 8 gallons, and 3 gallons, and a water faucet. You can fill the jugs up or empty them out from one to another or onto the ground. You need to measure out exactly one gallon. 
3.22 The missionaries and cannibals problem is usually stated as follows. Three mission- aries and three cannibals are on one side of a river, along with a boat that can hold one or two people. Find a way to get everyone to the other side, without ever leaving a group of mis- sionaries in one place outnumbered by the cannibals in that place. This problem is famous in AI because it was the subject of the first paper that approached problem formulation from an analytical viewpoint (Amarel, 1968). 
a. Formulate the problem precisely, making only those distinctions necessary to ensure a 
valid solution. Draw a diagram of the complete state space. b. Implement and solve the problem optimally using an appropriate search algorithm. Is it 
a good idea to check for repeated states? c. Why do you think people have a hard time solving this puzzle, given that the state space 
is so simple? 
3.23 Implement two versions of the RESULT(s,a) function for the 8-puzzle: one that copies and edits the data structure for the parent node s and one that modifies the parent state di- rectly (undoing the modifications as needed). Write versions of iterative deepening depth-first search that use these functions and compare their performance. 
3.24 On page 90, we mentioned iterative lengthening search, an iterative analog of uni- form cost search. The idea is to use increasing limits on path cost. If a node is generated whose path cost exceeds the current limit, it is immediately discarded. For each new itera- tion, the limit is set to the lowest path cost of any node discarded in the previous iteration. 
a. Show that this algorithm is optimal for general path costs. b. Consider a uniform tree with branching factor b, solution depth d, and unit step costs. 
How many iterations will iterative lengthening require? c. Now consider step costs drawn from the continuous range [ǫ,1] where 0 <ǫ< 1. How 
many iterations are required in the worst case? d. Implement the algorithm and apply it to instances of the 8-puzzle and traveling sales- person problems. Compare the algorithm’s performance to that of uniform-cost search, and comment on your results. 
3.25 Describe a state space in which iterative deepening search performs much worse than depth-first search (for example, O(n2) vs. O(n)). 
AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE 
Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
120 Chapter 3. Solving Problems by Searching 
DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
3.26 Write a program that will take as input two Web page URLs and find a path of links from one to the other. What is an appropriate search strategy? Is bidirectional search a good idea? Could a search engine be used to implement a predecessor function? 
3.27 Consider the problem of finding the shortest path between two points on a plane that has convex polygonal obstacles as shown in Figure 3.32. This is an idealization of the problem that a robot has to solve to navigate in a crowded environment. 
a. Suppose the state space consists of all positions (x, y) in the plane. How many states 
are there? How many paths are there to the goal? b. Explain briefly why the shortest path from one polygon vertex to any other in the scene must consist of straight-line segments joining some of the vertices of the polygons. Define a good state space now. How large is this state space? c. Define the necessary functions to implement the search problem, including an ACTIONS function that takes a vertex as input and returns a set of vectors, each of which maps the current vertex to one of the vertices that can be reached in a straight line. (Do not forget the neighbors on the same polygon.) Use the straight-line distance for the heuristic function. d. Apply one or more of the algorithms in this chapter to solve a range of problems in the 
domain, and comment on their performance. 
3.28 Compare the performance of A∗ and RBFS on a set of randomly generated problems in the 8-puzzle (with Manhattan distance) and TSP (with MST—see Exercise 3.38) domains. Discuss your results. What happens to the performance of RBFS when a small random num- ber is added to the heuristic values in the 8-puzzle domain? 
3.29 On page 69, we said that we would not consider problems with negative path costs. In this exercise, we explore this in more depth. 
AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE 
Figure 3.32 A scene with polygonal obstacles. S and G are the start and goal states. 
S 
G 
Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved. 
Section 3.7. Summary 121 
a. Suppose that actions can have arbitrarily large negative costs; explain why this possi- 
bility would force any optimal algorithm to explore the entire state space. b. Does it help if we insist that step costs must be greater than or equal to some negative 
constant c? Consider both trees and graphs. c. Suppose that there is a set of actions that form a loop in the state space, so that executing the set in some order results in no net change to the state. If all of these actions have negative cost, what does this imply about the optimal behavior for an agent in such an environment? d. One can easily imagine actions with high negative cost, even in domains such as route finding. For example, some stretches of road might have such beautiful scenery as to far outweigh the normal costs in terms of time and fuel. Explain, in precise terms, within the context of state-space search, why humans do not drive around scenic loops indefinitely, and explain how to define the state space and actions for route finding so that artificial agents can also avoid looping. e. Can you think of a real domain in which step costs are such as to cause looping? 
3.30 Consider the vacuum-world problem defined in Figure 2.2. 
a. Which of the algorithms defined in this chapter would be appropriate for this problem? 
Should the algorithm use tree search or graph search? b. Apply your chosen algorithm to compute an optimal sequence of actions for a 3×3 world whose initial state has dirt in the three top squares and the agent in the center. c. Construct a search agent for the vacuum world, and evaluate its performance in a set of 3×3 worlds with probability 0.2 of dirt in each square. Include the search cost as well as path cost in the performance measure, using a reasonable exchange rate. d. Compare your best search agent with a simple randomized reflex agent that sucks if 
there is dirt and otherwise moves randomly. e. Consider what would happen if the world were enlarged to n × n. How does the per- 
formance of the search agent and of the reflex agent vary with n? 
3.31 Trace the operation of A∗ search applied to the problem of getting to Bucharest from Lugoj using the straight-line distance heuristic. That is, show the sequence of nodes that the algorithm will consider and the f, g, and h score for each node. 
3.32 Sometimes there is no good evaluation function for a problem, but there is a good comparison method: a way to tell whether one node is better than another, without assigning numerical values to either. Show that this is enough to do a best-first search. Is there an analog of A∗ for this setting? 
3.33 Prove each of the following statements: 
a. Breadth-first search is a special case of uniform-cost search. b. Breadth-first search, depth-first search, and uniform-cost search are special cases of 
best-first search. c. Uniform-cost search is a special case of A∗ search. 
AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE 
Chapters 3 and 4 from Russell/Norvig, Artificial Intelligence, 3e, ISBN: 0136042597 ©2010 
122 Chapter 3. Solving Problems by Searching 
3.34 Devise a state space in which A∗ using GRAPH-SEARCH returns a suboptimal solution with an h(n) function that is admissible but inconsistent. 
3.35 We saw on page 94 that the straight-line distance heuristic leads greedy best-first search astray on the problem of going from Iasi to Fagaras. However, the heuristic is per- fect on the opposite problem: going from Fagaras to Iasi. Are there problems for which the heuristic is misleading in both directions? 
3.36 Invent a heuristic function for the 8-puzzle that sometimes overestimates, and show how it can lead to a suboptimal solution on a particular problem. (You can use a computer to help if you want.) Prove that, if h never overestimates by more than c, A∗ using h returns a solution whose cost exceeds that of the optimal solution by no more than c. 
3.37 Prove that if a heuristic is consistent, it must be admissible. Construct an admissible heuristic that is not consistent. 
3.38 The traveling salesperson problem (TSP) can be solved via the minimum-spanning- tree (MST) heuristic, which is used to estimate the cost of completing a tour, given that a partial tour has already been constructed. The MST cost of a set of cities is the smallest sum of the link costs of any tree that connects all the cities. 
a. Show how this heuristic can be derived from a relaxed version of the TSP. b. Show that the MST heuristic dominates straight-line distance. c. Write a problem generator for instances of the TSP where cities are represented by 
random points in the unit square. d. Find an efficient algorithm in the literature for constructing the MST, and use it with A∗ 
graph search to solve instances of the TSP. 
3.39 On page 106, we defined the relaxation of the 8-puzzle in which a tile can move from square A to square B if B is blank. The exact solution of this problem defines Gaschnig’s heuristic (Gaschnig, 1979). Explain why Gaschnig’s heuristic is at least as accurate as h1 (misplaced tiles), and show cases where it is more accurate than both h1 and h2 (Manhattan distance). Can you suggest a way to calculate Gaschnig’s heuristic efficiently? 
3.40 We gave two simple heuristics for the 8-puzzle: Manhattan distance and misplaced tiles. Several heuristics in the literature purport to improve on this—see, for example, Nils- son (1971), Mostow and Prieditis (1989), and Hansson et al. (1992). Test these claims by implementing the heuristics and comparing the performance of the resulting algorithms. 
AIMA3e c 2008 by Russell and Norvig. DRAFT---DO NOT DISTRIBUTE 
DRAFT - For preview purposes only. Content is subject to change before final publication. ©2010 Pearson Education, Inc. Upper Saddle River, NJ 07458. All Rights Reserved.